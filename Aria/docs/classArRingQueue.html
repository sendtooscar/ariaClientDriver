<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Aria: ArRingQueue&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ArRingQueue&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="ArRingQueue" --><code>#include &lt;ArRingQueue.h&gt;</code>
<p>

<p>
<a href="classArRingQueue-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class ArRingQueue&lt; T &gt;</h3>

An expanding ring queue. 
<p>
It is used to keep a queue with a minimum of allocation and freeing of heap memory. The ring queue is implemented using std::list. The queue starts with an initial capacity, but those initial items are considered 'unused'. Items are "pushed" into the queue at the "back", and "popped" from the queue at the "front". pop() and <a class="el" href="classArRingQueue.html#7fa7e60371c7601f4e794d3e21e708f2">advance_front()</a> will move the front of the queue to the next item, creating a new 'unused slot' for future use; <a class="el" href="classArRingQueue.html#e73cb1d2cec1e663c1157bc71b1d7f4d">advance_back()</a> changes the next item in the back to a 'used' slot. <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a> either uses the next 'unused' slot, or inserts a new item into the std::list. When the capacity of the queue is filled, all operations will fail except <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a>. Use <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a> to insert new items in the queue and increase its capacity.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#e73cb1d2cec1e663c1157bc71b1d7f4d">advance_back</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#7fa7e60371c7601f4e794d3e21e708f2">advance_front</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#27771d7817cc4d0453d0b6b215913406">ArRingQueue</a> (int capacity, T init_value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#c8121a2877cfd695eed752e38249e196">back</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#8d871f45e6528a36060b5541bee81fdb">capacity</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#fab0881bade43ecf422ec9a472d2acd3">empty</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#daee28c1ea0a02b095691c9889d6058a">front</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#18f53abdfb4bc727120b62d814964cb8">full</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#13605ef610f6092febeef27017e42a09">nil</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#0e3239e02c975282a01f5a2c9f6daede">pop_front</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#1a049222bb51b8c94383b9669bbd4462">print</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push</a> (const T &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#929c549542dcfd3b8cbc4a0d0d838347">push_back</a> (const T &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#aac6c08ebabfa4bc5aa36375e7d98e7a">push_without_expanding</a> (const T &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#16e45c61b16569112fa265c9d3d305c1">reset</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRingQueue.html#f0a4a6353e476f0c592e2ce973c50d45">size</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="137b4511f42c7c89f39628c4f0fadd77"></a><!-- doxytag: member="ArRingQueue::back_it" ref="137b4511f42c7c89f39628c4f0fadd77" args="" -->
std::list&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>back_it</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="485ae4c6963acb5d65cd46e810bf5f84"></a><!-- doxytag: member="ArRingQueue::curSize" ref="485ae4c6963acb5d65cd46e810bf5f84" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>curSize</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d97b459ece928efe22c4c7349c730e68"></a><!-- doxytag: member="ArRingQueue::front_it" ref="d97b459ece928efe22c4c7349c730e68" args="" -->
std::list&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>front_it</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d39ad7769e9ddec117d693d99536acc"></a><!-- doxytag: member="ArRingQueue::initval" ref="1d39ad7769e9ddec117d693d99536acc" args="" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><b>initval</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dbab8c20581b04a7c51af5b4a6c5800e"></a><!-- doxytag: member="ArRingQueue::ring" ref="dbab8c20581b04a7c51af5b4a6c5800e" args="" -->
std::list&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ring</b></td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="27771d7817cc4d0453d0b6b215913406"></a><!-- doxytag: member="ArRingQueue::ArRingQueue" ref="27771d7817cc4d0453d0b6b215913406" args="(int capacity, T init_value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::<a class="el" href="classArRingQueue.html">ArRingQueue</a>           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>init_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>Initial capacity of the ring queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init_value</em>&nbsp;</td><td>Initial value for new, unused items in the queue. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e73cb1d2cec1e663c1157bc71b1d7f4d"></a><!-- doxytag: member="ArRingQueue::advance_back" ref="e73cb1d2cec1e663c1157bc71b1d7f4d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::advance_back           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance the back (an 'empty' push), if the queue is not full. 'Used' size will be incremented. 
</div>
</div><p>
<a class="anchor" name="7fa7e60371c7601f4e794d3e21e708f2"></a><!-- doxytag: member="ArRingQueue::advance_front" ref="7fa7e60371c7601f4e794d3e21e708f2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::advance_front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance (pop) the front of the queue. 'Used' size will be decremented. 
</div>
</div><p>
<a class="anchor" name="c8121a2877cfd695eed752e38249e196"></a><!-- doxytag: member="ArRingQueue::back" ref="c8121a2877cfd695eed752e38249e196" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;T&gt;::iterator <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::back           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator for the back of the queue (the item that would be replaced by <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a>). This is not the last item in the queue, rather it is the next, unused, "slot". If the queue is full, an iterator equivalent to that returned by <a class="el" href="classArRingQueue.html#13605ef610f6092febeef27017e42a09">nil()</a> is returned.<p>
To add an item to the queue without pushing a copy with <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a>, first check if the queue is full (in which case you must <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a> your item). Then use this function to write the data into the next unused 'slot'. Then call <a class="el" href="classArRingQueue.html#e73cb1d2cec1e663c1157bc71b1d7f4d">advance_back()</a> to advance the back of the queue to your new item. 
</div>
</div><p>
<a class="anchor" name="8d871f45e6528a36060b5541bee81fdb"></a><!-- doxytag: member="ArRingQueue::capacity" ref="8d871f45e6528a36060b5541bee81fdb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::capacity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current capacity of the queue. 
</div>
</div><p>
<a class="anchor" name="fab0881bade43ecf422ec9a472d2acd3"></a><!-- doxytag: member="ArRingQueue::empty" ref="fab0881bade43ecf422ec9a472d2acd3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::empty           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the queue is empty (has no 'used' items), false otherwise. 
</div>
</div><p>
<a class="anchor" name="daee28c1ea0a02b095691c9889d6058a"></a><!-- doxytag: member="ArRingQueue::front" ref="daee28c1ea0a02b095691c9889d6058a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;T&gt;::iterator <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator for the front item of the ring queue (the item that would be returned by pop()). If the queue is currently empty, <a class="el" href="classArRingQueue.html#13605ef610f6092febeef27017e42a09">nil()</a> will be returned.<p>
To remove an item from the queue without making a copy with pop(), first check if the queue is <a class="el" href="classArRingQueue.html#fab0881bade43ecf422ec9a472d2acd3">empty()</a>. Then use this function to get the data. Then call <a class="el" href="classArRingQueue.html#7fa7e60371c7601f4e794d3e21e708f2">advance_front()</a>. 
</div>
</div><p>
<a class="anchor" name="18f53abdfb4bc727120b62d814964cb8"></a><!-- doxytag: member="ArRingQueue::full" ref="18f53abdfb4bc727120b62d814964cb8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::full           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the queue is full, false otherwise. 
</div>
</div><p>
<a class="anchor" name="13605ef610f6092febeef27017e42a09"></a><!-- doxytag: member="ArRingQueue::nil" ref="13605ef610f6092febeef27017e42a09" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;T&gt;::iterator <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::nil           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an iterator representing an invalid item. Compare to the return values of <a class="el" href="classArRingQueue.html#daee28c1ea0a02b095691c9889d6058a">front()</a>, <a class="el" href="classArRingQueue.html#c8121a2877cfd695eed752e38249e196">back()</a>, pop(), etc. 
</div>
</div><p>
<a class="anchor" name="0e3239e02c975282a01f5a2c9f6daede"></a><!-- doxytag: member="ArRingQueue::pop_front" ref="0e3239e02c975282a01f5a2c9f6daede" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::pop_front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classArRingQueue.html#7fa7e60371c7601f4e794d3e21e708f2">advance_front()</a> 
</div>
</div><p>
<a class="anchor" name="1a049222bb51b8c94383b9669bbd4462"></a><!-- doxytag: member="ArRingQueue::print" ref="1a049222bb51b8c94383b9669bbd4462" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::print           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the current contents of the queue. <p>
<b>Python Wrapper Library:</b> use printQueue() instead of <a class="el" href="classArRingQueue.html#1a049222bb51b8c94383b9669bbd4462">print()</a> (which is a reserved word in Python) 
</div>
</div><p>
<a class="anchor" name="0de53f01e95093f30083dc551081e51b"></a><!-- doxytag: member="ArRingQueue::push" ref="0de53f01e95093f30083dc551081e51b" args="(const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::push           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an item to the back of the ring queue. If the queue is full, the capacity of the queue will be expanded and the item will be inserted. 
</div>
</div><p>
<a class="anchor" name="929c549542dcfd3b8cbc4a0d0d838347"></a><!-- doxytag: member="ArRingQueue::push_back" ref="929c549542dcfd3b8cbc4a0d0d838347" args="(const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::push_back           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classArRingQueue.html#0de53f01e95093f30083dc551081e51b">push()</a> 
</div>
</div><p>
<a class="anchor" name="aac6c08ebabfa4bc5aa36375e7d98e7a"></a><!-- doxytag: member="ArRingQueue::push_without_expanding" ref="aac6c08ebabfa4bc5aa36375e7d98e7a" args="(const T &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::push_without_expanding           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Push a new item, but preserve capacity: instead of expanding the queue if full, then the oldest item is replaced and the front is advanced. 
</div>
</div><p>
<a class="anchor" name="16e45c61b16569112fa265c9d3d305c1"></a><!-- doxytag: member="ArRingQueue::reset" ref="16e45c61b16569112fa265c9d3d305c1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::reset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Logically clear the queue, resetting to initial empty state, but preserving current capacity, and leaving all contents as they are; the contents are not destroyed, but will be when replaced by new data later. 
</div>
</div><p>
<a class="anchor" name="f0a4a6353e476f0c592e2ce973c50d45"></a><!-- doxytag: member="ArRingQueue::size" ref="f0a4a6353e476f0c592e2ce973c50d45" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classArRingQueue.html">ArRingQueue</a>&lt; T &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of items currently 'used' in the queue. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ArRingQueue.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 1 12:22:52 2012 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
