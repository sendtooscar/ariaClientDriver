<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Aria: ArMapInterface Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ArMapInterface Class Reference</h1><!-- doxytag: class="ArMapInterface" --><!-- doxytag: inherits="ArMapInfoInterface,ArMapObjectsInterface,ArMapScanInterface,ArMapSupplementInterface" --><code>#include &lt;ArMapInterface.h&gt;</code>
<p>
Inherits <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a>, <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a>, <a class="el" href="classArMapScanInterface.html">ArMapScanInterface</a>, and <a class="el" href="classArMapSupplementInterface.html">ArMapSupplementInterface</a>.
<p>
Inherited by <a class="el" href="classArMap.html">ArMap</a>, and <a class="el" href="classArMapSimple.html">ArMapSimple</a>.
<p>

<p>
<a href="classArMapInterface-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classArMapInterface.html">ArMapInterface</a> defines the methods that are available on all <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> maps. These maps represent the operating space of a robot, and can be used for space searching, localizing, navigating etc. The types of data stored in a map include sensable obstacles (e.g. walls and furniture in a room) represented either as a collection of data points (similar to a raster or bit map, useful for high resolution sensors like a laser), or lines (a vector map, useful for low resolution sensors like the sonar), goals, and other points or regions of interest ("map objects").<p>
The methods in <a class="el" href="classArMapInterface.html">ArMapInterface</a> can be broadly categorized as follows:<ul>
<li>Scan Methods: These provide access the sensable obstacles that are represented as a collection of data points or lines. These are typically generated during the scanning process (i.e. the creation of the .2d file). If more than one sensor is used, then the data is organized on a per-sensor basis. The scan methods are grouped into the <a class="el" href="classArMapScanInterface.html" title="Methods related to setting and retrieving the scan-related data in an Aria map.">ArMapScanInterface</a>.</li><li>Object Methods: These provide access to the "high-level" objects in the environment. Such objects include goals, docks, forbidden areas, and other user-defined points of interest. They may also include special data objects that are actually part of the operating environment and are generally added automatically and are not editable by the user. The object methods are grouped into the <a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a>.</li><li>Info Methods: A wide variety of supporting information is included in various "info" categories. This includes definitions for the types of map objects that can be stored in the map. It also includes various optional features such as macros and schedules. The info methods are grouped into the <a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an...">ArMapInfoInterface</a>.</li><li>Extra Data Methods: These are essentially the "leftovers" -- i.e. methods that are related directly to map data but which do not fit into any of the above categories. They are defined in the <a class="el" href="classArMapSupplementInterface.html" title="Methods related to miscellaneous extra data in an Aria map.">ArMapSupplementInterface</a>.</li><li>Callback Methods: Users of the <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map may install callbacks onto the map in order to be notified when the map contents has changed. These methods are defined below.</li><li>File and I/O Methods: Methods to read and write map files are also included below. In addition, the MD5 checksum of the map contents may be calculated.</li></ul>
<p>
TODO:<ul>
<li>Possibly make the calculation of checksums optional? </li></ul>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classArMapInterface.html#27a762fba2516a50ff30449feb8ac18440732d41ab529094aace100632e2c16b">MAX_MAP_NAME_LENGTH</a> =  512
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#00d82761b4bf3a9f6402a7a1696aa8fd">addMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=ArListPos::LAST)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a callback that is invoked when the map has been changed.  <a href="#00d82761b4bf3a9f6402a7a1696aa8fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#40d8eea550274935ff957b93f340dc60">addPostWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=ArListPos::LAST)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a callback to be invoked after the map file is written.  <a href="#40d8eea550274935ff957b93f340dc60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#2ef2626f03eaccdafeb53d93cd2a443c">addPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=ArListPos::LAST)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a callback called before the map changed callbacks are called.  <a href="#2ef2626f03eaccdafeb53d93cd2a443c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#7b1e1bc876eba9f442f170449b79f69e">addPreWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=ArListPos::LAST)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a callback to be invoked before the map file is written.  <a href="#7b1e1bc876eba9f442f170449b79f69e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe8e08b6c419a144dc5622b785c584df"></a><!-- doxytag: member="ArMapInterface::ArMapInterface" ref="fe8e08b6c419a144dc5622b785c584df" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#fe8e08b6c419a144dc5622b785c584df">ArMapInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#11d230f4851af9cd23683ec1b425f7e8">calculateChecksum</a> (unsigned char *md5DigestBuffer, size_t md5DigestBufferLen)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the checksum of the map.  <a href="#11d230f4851af9cd23683ec1b425f7e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3545fd896f5bfa3b23c3585483d7aa8e"></a><!-- doxytag: member="ArMapInterface::clear" ref="3545fd896f5bfa3b23c3585483d7aa8e" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#3545fd896f5bfa3b23c3585483d7aa8e">clear</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the map, removing all info, objects and data points and lines. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArMapInterface.html">ArMapInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#bc68f5bb2b270a3621206c0bb60de750">clone</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new map that is "equivalent" to this map.  <a href="#bc68f5bb2b270a3621206c0bb60de750"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c7ea2928593dabdb79eaf328f803123"></a><!-- doxytag: member="ArMapInterface::createRealFileName" ref="1c7ea2928593dabdb79eaf328f803123" args="(const char *fileName)=0" -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#1c7ea2928593dabdb79eaf328f803123">createRealFileName</a> (const char *fileName)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepends the appropriate directory information on the given filename. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#69999157a3713d4ada7d47f6a3087b73">findMapObjectParams</a> (const char *mapObjectName)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the optional parameters associated with a map object, or NULL if none.  <a href="#69999157a3713d4ada7d47f6a3087b73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a75aadc1642ea9f8f6004c09fa94306"></a><!-- doxytag: member="ArMapInterface::getBaseDirectory" ref="6a75aadc1642ea9f8f6004c09fa94306" args="(void) const =0" -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#6a75aadc1642ea9f8f6004c09fa94306">getBaseDirectory</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the base directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e4b9de7ebaa896d12728e2b16d5eb0f"></a><!-- doxytag: member="ArMapInterface::getFileName" ref="4e4b9de7ebaa896d12728e2b16d5eb0f" args="(void) const =0" -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#4e4b9de7ebaa896d12728e2b16d5eb0f">getFileName</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the fileName that was loaded. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#bd35c2a4363d41c6633fd064a45188bd">getIgnoreCase</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether we ignore case or not.  <a href="#bd35c2a4363d41c6633fd064a45188bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#e71fec67708492f07fe4cf88fe5bd570">getIgnoreEmptyFileName</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether we ignore empty file names or fail if we encounter one.  <a href="#e71fec67708492f07fe4cf88fe5bd570"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#f71351c58a7c772b852002babf282220">getInactiveInfo</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides direct access to the inactive map info.  <a href="#f71351c58a7c772b852002babf282220"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#06520aefeb5654a4b4adae7f4b5c0e5a">getInactiveObjects</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides direct access to the inactive map objects.  <a href="#06520aefeb5654a4b4adae7f4b5c0e5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55d2dc775f7dfb095f4a97c1c8493f82"></a><!-- doxytag: member="ArMapInterface::getMapChangedLogLevel" ref="55d2dc775f7dfb095f4a97c1c8493f82" args="(void)=0" -->
virtual <a class="el" href="classArLog.html#c8cc0fb3aa323ab2a1c21340fdd1dce3">ArLog::LogLevel</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#55d2dc775f7dfb095f4a97c1c8493f82">getMapChangedLogLevel</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the level at which information about the map changed callbacks is logged. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#42438b0cdb01d4f1613b05dcaa8bae60">getMapId</a> (<a class="el" href="classArMapId.html">ArMapId</a> *mapIdOut, bool isInternalCall=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the map ID.  <a href="#42438b0cdb01d4f1613b05dcaa8bae60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual struct stat&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#b9736c0a90ec57e51b3415ef787de861">getReadFileStat</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns information about the map file that was read.  <a href="#b9736c0a90ec57e51b3415ef787de861"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::list<br>
&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#33d5f7c640ead8c14268379b35d5cbe0">getRemainder</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of the map file lines that were not recognized.  <a href="#33d5f7c640ead8c14268379b35d5cbe0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::list&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#f1c75dac69881ba57ffd7826dd600a32">getScanTypes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of the scan types that are defined for this map.  <a href="#f1c75dac69881ba57ffd7826dd600a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15ff7bcde5b7655300e8e35f59eaab7a"></a><!-- doxytag: member="ArMapInterface::getTempDirectory" ref="15ff7bcde5b7655300e8e35f59eaab7a" args="(void) const =0" -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#15ff7bcde5b7655300e8e35f59eaab7a">getTempDirectory</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the temp directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#660969c77405c2795a47ce58f0625977">isLoadingDataStarted</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#6d2628ce711c2d6774746586932f7913">isLoadingLinesAndDataStarted</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e72e85ff0680d98570b096cf24938ba"></a><!-- doxytag: member="ArMapInterface::lock" ref="2e72e85ff0680d98570b096cf24938ba" args="()=0" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba">lock</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the map instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#00f12f15367b9c97592b0f45fda2fc2f">mapChanged</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that will call the map changed CBs if needed.  <a href="#00f12f15367b9c97592b0f45fda2fc2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#7a5270bda8f803df83079940ac6e15e5">parseLine</a> (char *line)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses a map line.  <a href="#7a5270bda8f803df83079940ac6e15e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7aa64d691b47caab38efa72a90767294"></a><!-- doxytag: member="ArMapInterface::parsingComplete" ref="7aa64d691b47caab38efa72a90767294" args="(void)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#7aa64d691b47caab38efa72a90767294">parsingComplete</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Says that the parsing by lines is done and to use the parsed data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#9ec33c9ef77c8d6fcd6f68b33d0385d9">readFile</a> (const char *fileName, char *errorBuffer=NULL, size_t errorBufferLen=0, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the map from the specified file.  <a href="#9ec33c9ef77c8d6fcd6f68b33d0385d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#412f9906797ed2e34e6d4589033e3d80">refresh</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the map file needs to be re-read.  <a href="#412f9906797ed2e34e6d4589033e3d80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#65da492e1379f9a9d226b552a2be65d3">remMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a callback called when the map has been changed.  <a href="#65da492e1379f9a9d226b552a2be65d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#80f3ea46ca3969d4eaf6253b39c84f5c">remPostWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the given callback from the list of post-write callbacks.  <a href="#80f3ea46ca3969d4eaf6253b39c84f5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#0563d1953c0795a0ee85ebb2a7c9b13c">remPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the specified "pre-map-changed callback".  <a href="#0563d1953c0795a0ee85ebb2a7c9b13c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#44fbadba38009509c473ca622a59b8b1">remPreWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the given callback from the list of pre-write callbacks.  <a href="#44fbadba38009509c473ca622a59b8b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#20061ab5be4b9b469a7221ca12fdd9be">set</a> (<a class="el" href="classArMapInterface.html">ArMapInterface</a> *other)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets this map to be "equivalent" to the given other map.  <a href="#20061ab5be4b9b469a7221ca12fdd9be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2389288fc4c29e1d380cd961877c2acd"></a><!-- doxytag: member="ArMapInterface::setBaseDirectory" ref="2389288fc4c29e1d380cd961877c2acd" args="(const char *baseDirectory)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#2389288fc4c29e1d380cd961877c2acd">setBaseDirectory</a> (const char *baseDirectory)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the base directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#60ca7573c074769719b00c3c96ec17c4">setIgnoreCase</a> (bool ignoreCase=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether we ignore case or not.  <a href="#60ca7573c074769719b00c3c96ec17c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a65367c7823f46fdae42d53f201699a5">setIgnoreEmptyFileName</a> (bool ignore)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether we ignore empty file names or fail if we encounter one.  <a href="#a65367c7823f46fdae42d53f201699a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5774ac76e0e7dc6b47a5125bc00c2b51"></a><!-- doxytag: member="ArMapInterface::setMapChangedLogLevel" ref="5774ac76e0e7dc6b47a5125bc00c2b51" args="(ArLog::LogLevel level)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#5774ac76e0e7dc6b47a5125bc00c2b51">setMapChangedLogLevel</a> (<a class="el" href="classArLog.html#c8cc0fb3aa323ab2a1c21340fdd1dce3">ArLog::LogLevel</a> level)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the level at which to log information about the map changed callbacks. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#cac90c5ce18a25ecd6d08ce8116a27aa">setMapObjectParams</a> (const char *mapObjectName, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *params, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the optional parameters associated with a map object.  <a href="#cac90c5ce18a25ecd6d08ce8116a27aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3226d90f6e888de43fa4ab4e86c1a52"></a><!-- doxytag: member="ArMapInterface::setQuiet" ref="c3226d90f6e888de43fa4ab4e86c1a52" args="(bool isQuiet)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#c3226d90f6e888de43fa4ab4e86c1a52">setQuiet</a> (bool isQuiet)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn on this flag to reduce the number of verbose log messages. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#c519568cc0d2e3a87d4e7feabf04a7aa">setScanTypes</a> (const std::list&lt; std::string &gt; &amp;scanTypeList)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the scan types that are defined for this map.  <a href="#c519568cc0d2e3a87d4e7feabf04a7aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#dc9644192ab38bd3b8a019d6e910ef42">setSourceFileName</a> (const char *sourceName, const char *fileName, bool isInternalCall=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of the source and the file from which the map was loaded.  <a href="#dc9644192ab38bd3b8a019d6e910ef42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3dbb287b9996bc395755015c6474b01c"></a><!-- doxytag: member="ArMapInterface::setTempDirectory" ref="3dbb287b9996bc395755015c6474b01c" args="(const char *tempDirectory)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#3dbb287b9996bc395755015c6474b01c">setTempDirectory</a> (const char *tempDirectory)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the temp directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43cd5a39e989e99453e59fad86408897"></a><!-- doxytag: member="ArMapInterface::tryLock" ref="43cd5a39e989e99453e59fad86408897" args="()=0" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#43cd5a39e989e99453e59fad86408897">tryLock</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock the map instance without blocking. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f53472e8700abcc05a85b9f7a7d6820"></a><!-- doxytag: member="ArMapInterface::unlock" ref="0f53472e8700abcc05a85b9f7a7d6820" args="()=0" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#0f53472e8700abcc05a85b9f7a7d6820">unlock</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the map instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#de2aaba8c0a991964c2a623987a589fe">writeFile</a> (const char *fileName, bool internalCall=false, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0, time_t fileTimestamp=-1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the map to the specified file.  <a href="#de2aaba8c0a991964c2a623987a589fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#bc4e372308bbf06195dea3c0bccc93b8">writeObjectsToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars, bool isOverrideAsSingleScan=false, const char *maxCategory=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the map header information and objects to a text-based functor.  <a href="#bc4e372308bbf06195dea3c0bccc93b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#4721211e839289dc8ab24202e07471cc">writeToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes all of the map to the given text-based functor.  <a href="#4721211e839289dc8ab24202e07471cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3a168bc2130af13b415979a75e536fa"></a><!-- doxytag: member="ArMapInterface::~ArMapInterface" ref="b3a168bc2130af13b415979a75e536fa" args="(void)" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#b3a168bc2130af13b415979a75e536fa">~ArMapInterface</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#adffe2b39f07bbc856355e1b70a08be0">createRealFileName</a> (const char *baseDirectory, const char *fileName, bool isIgnoreCase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method creates a full file path name from the given components.  <a href="#adffe2b39f07bbc856355e1b70a08be0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="534fc541999ac13d2afb7297458e0a28"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D" ref="534fc541999ac13d2afb7297458e0a28" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>MAP_CATEGORY_2D</b> = &quot;2D-Map&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ecb554bd7784500b4495dbc8a64fb71"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D_EXTENDED" ref="0ecb554bd7784500b4495dbc8a64fb71" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#0ecb554bd7784500b4495dbc8a64fb71">MAP_CATEGORY_2D_EXTENDED</a> = &quot;2D-Map-Ex2&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Superset of multi-sources; includes advanced Info types. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d893149ccf58439c104cae7b77e01fc6"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D_MULTI_SOURCES" ref="d893149ccf58439c104cae7b77e01fc6" args="" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>MAP_CATEGORY_2D_MULTI_SOURCES</b> = &quot;2D-Map-Ex&quot;</td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="27a762fba2516a50ff30449feb8ac184"></a><!-- doxytag: member="ArMapInterface::@11" ref="27a762fba2516a50ff30449feb8ac184" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="27a762fba2516a50ff30449feb8ac18440732d41ab529094aace100632e2c16b"></a><!-- doxytag: member="MAX_MAP_NAME_LENGTH" ref="27a762fba2516a50ff30449feb8ac18440732d41ab529094aace100632e2c16b" args="" -->MAX_MAP_NAME_LENGTH</em>&nbsp;</td><td>
Maximum length of the map file's name. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="00d82761b4bf3a9f6402a7a1696aa8fd"></a><!-- doxytag: member="ArMapInterface::addMapChangedCB" ref="00d82761b4bf3a9f6402a7a1696aa8fd" args="(ArFunctor *functor, ArListPos::Pos position=ArListPos::LAST)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addMapChangedCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>ArListPos::LAST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a callback that is invoked when the map has been changed. 
<p>
The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>the <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40d8eea550274935ff957b93f340dc60"></a><!-- doxytag: member="ArMapInterface::addPostWriteFileCB" ref="40d8eea550274935ff957b93f340dc60" args="(ArFunctor *functor, ArListPos::Pos position=ArListPos::LAST)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPostWriteFileCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>ArListPos::LAST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a callback to be invoked after the map file is written. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> * callback to be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>the <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> that specifies whether the callback should be added at the front or the back of the list </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2ef2626f03eaccdafeb53d93cd2a443c"></a><!-- doxytag: member="ArMapInterface::addPreMapChangedCB" ref="2ef2626f03eaccdafeb53d93cd2a443c" args="(ArFunctor *functor, ArListPos::Pos position=ArListPos::LAST)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPreMapChangedCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>ArListPos::LAST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a callback called before the map changed callbacks are called. 
<p>
The "pre-map-changed callbacks" are invoked *after* the map has been changed, but before the other "map-changed callbacks" are invoked. This method is not thread-safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>the <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7b1e1bc876eba9f442f170449b79f69e"></a><!-- doxytag: member="ArMapInterface::addPreWriteFileCB" ref="7b1e1bc876eba9f442f170449b79f69e" args="(ArFunctor *functor, ArListPos::Pos position=ArListPos::LAST)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::addPreWriteFileCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>ArListPos::LAST</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a callback to be invoked before the map file is written. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> * callback to be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>the <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> that specifies whether the callback should be added at the front or the back of the list </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="11d230f4851af9cd23683ec1b425f7e8"></a><!-- doxytag: member="ArMapInterface::calculateChecksum" ref="11d230f4851af9cd23683ec1b425f7e8" args="(unsigned char *md5DigestBuffer, size_t md5DigestBufferLen)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::calculateChecksum           </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>md5DigestBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>md5DigestBufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the checksum of the map. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>md5DigestBuffer</em>&nbsp;</td><td>the unsigned char buffer in which to store the calculated checksum </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>md5DigestBufferLen</em>&nbsp;</td><td>the length of the md5DigestBuffer; should be <a class="el" href="classArMD5Calculator.html#6a443ef94c7ef16e4d5adfcfcbf785a21c49adf9388dec84457b4f47ec6a0cbb" title="Number of bytes in the checksum buffer.">ArMD5Calculator::DIGEST_LENGTH</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the checksum was successfully calculated; false if an error occurrred </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors...">ArMD5Calculator</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc68f5bb2b270a3621206c0bb60de750"></a><!-- doxytag: member="ArMapInterface::clone" ref="bc68f5bb2b270a3621206c0bb60de750" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapInterface.html">ArMapInterface</a>* ArMapInterface::clone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new map that is "equivalent" to this map. 
<p>
Creates a new map that is effectively a copy of this map. Note, however, that the returned map may not be of exactly the same class (so the term "clone" is being used somewhat loosely). In particular, if the active <a class="el" href="classArMap.html" title="A map of a space the robot can navigate within, and which can be updated via the...">ArMap</a> that is associated with the robot configuration is cloned, then the resulting map will be simpler and not associated with the robot configuration. <dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classArMapInterface.html">ArMapInterface</a> * a new copy of this map </dd></dl>
<b>Java Wrapper Library:</b> Use cloneMap() instead 
</div>
</div><p>
<a class="anchor" name="adffe2b39f07bbc856355e1b70a08be0"></a><!-- doxytag: member="ArMapInterface::createRealFileName" ref="adffe2b39f07bbc856355e1b70a08be0" args="(const char *baseDirectory, const char *fileName, bool isIgnoreCase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ArMapInterface::createRealFileName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>baseDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isIgnoreCase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper method creates a full file path name from the given components. 
<p>
Determines what system file path to use based on the contents of <em>baseDirectory</em>, <em>fileName</em> and <em>isIgnoreCase</em>. If <em>fileName</em> is not an absolute path and <em>baseDirectory</em> is not null and not empty, then it is combined with <em>baseDirectory</em> to form a full path. An absolute path starts with the '/' or '\' character, or on Windows, with "X:\" where X is any upper or lower case alphabetic character A-Z or a-z. 
</div>
</div><p>
<a class="anchor" name="69999157a3713d4ada7d47f6a3087b73"></a><!-- doxytag: member="ArMapInterface::findMapObjectParams" ref="69999157a3713d4ada7d47f6a3087b73" args="(const char *mapObjectName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a>* ArMapInterface::findMapObjectParams           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mapObjectName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the optional parameters associated with a map object, or NULL if none. 
<p>
The <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map provides an advanced feature that allows a parameter list to be defined for custom map object types. (Refer to the <a class="el" href="classArMap.html" title="A map of a space the robot can navigate within, and which can be updated via the...">ArMap</a> MapFileFormat for more information.)<p>
This convenience method provides access to the parameter values for a specified map object. It is basically a shortcut for searching and parsing the CairnInfo argument list. Unlike the CairnInfo arguments (which also include an introduction and map object name), the argument builder returned by this method only contains the parameter values. Also note that if the argument builder contains string parameters, then they may be surrounded by quotes.<p>
The returned pointer should not be stored, modified, or deleted.<p>
See setMapObjectParams for important information about changing the parameter values or the associated map object.<p>
This method is not thread-safe. (The call and use of the returned <a class="el" href="classArArgumentBuilder.html" title="This class is to build arguments for things that require argc and argv.">ArArgumentBuilder</a> should be surrounded by calls to <a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>/unlock().)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapObjectName</em>&nbsp;</td><td>the unique char * name of the map object whose parameters are to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classArArgumentBuilder.html" title="This class is to build arguments for things that require argc and argv.">ArArgumentBuilder</a> * a pointer to the map object's parameter values; </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd35c2a4363d41c6633fd064a45188bd"></a><!-- doxytag: member="ArMapInterface::getIgnoreCase" ref="bd35c2a4363d41c6633fd064a45188bd" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::getIgnoreCase           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether we ignore case or not. 
<p>
This method is primarily applicable to the active <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that is associated with the robot configuration. 
</div>
</div><p>
<a class="anchor" name="e71fec67708492f07fe4cf88fe5bd570"></a><!-- doxytag: member="ArMapInterface::getIgnoreEmptyFileName" ref="e71fec67708492f07fe4cf88fe5bd570" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::getIgnoreEmptyFileName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether we ignore empty file names or fail if we encounter one. 
<p>
This method is primarily applicable to the active <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that is associated with the robot configuration. 
</div>
</div><p>
<a class="anchor" name="f71351c58a7c772b852002babf282220"></a><!-- doxytag: member="ArMapInterface::getInactiveInfo" ref="f71351c58a7c772b852002babf282220" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a>* ArMapInterface::getInactiveInfo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides direct access to the inactive map info. 
<p>
The "inactive" info is a section of the <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that applications may use to store "_XInfo:" lines that are not currently active or applicable. The inactive info will be written to the map file, but it will not be included in any of the inherited <a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an...">ArMapInfoInterface</a> calls (e.g. getInfo(type)). This is primarily intended for advanced specialized use where something needs to be removed from the map file, but it may be necessary to restore it later. This method is not thread-safe. <dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an...">ArMapInfoInterface</a> * a pointer to the inactive map info section </dd></dl>

</div>
</div><p>
<a class="anchor" name="06520aefeb5654a4b4adae7f4b5c0e5a"></a><!-- doxytag: member="ArMapInterface::getInactiveObjects" ref="06520aefeb5654a4b4adae7f4b5c0e5a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a>* ArMapInterface::getInactiveObjects           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides direct access to the inactive map objects. 
<p>
The "inactive" objects is a section of the <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that applications may use to store "_Cairn" lines that are not currently active or applicable. The inactive objects will be written to the map file, but they will not be included in any of the inherited <a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a> calls (e.g. <a class="el" href="classArMapObjectsInterface.html#66394898f80b1917b5f96aa4b7a8e37c" title="Returns a pointer to the internal list of map objects.">getMapObjects()</a>). This is primarily intended for advanced specialized use where an object needs to be removed from the map file, but it may be necessary to restore it later. This method is not thread-safe. <dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a> * a pointer to the inactive map objects section </dd></dl>

</div>
</div><p>
<a class="anchor" name="42438b0cdb01d4f1613b05dcaa8bae60"></a><!-- doxytag: member="ArMapInterface::getMapId" ref="42438b0cdb01d4f1613b05dcaa8bae60" args="(ArMapId *mapIdOut, bool isInternalCall=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::getMapId           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArMapId.html">ArMapId</a> *&nbsp;</td>
          <td class="paramname"> <em>mapIdOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isInternalCall</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the map ID. 
<p>
The map ID is a unique identifier based on the map file name and the checksum data. (Perhaps more accurately, it is highly likely to be unique during normal usage.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapIdOut</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArMapId.html" title="Enapsulates the data used to uniquely identify an Aria map.">ArMapId</a> to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isInternalCall</em>&nbsp;</td><td>a bool set to true only when getMapId is called within the context of a method that has already locked the map; if false, then the map is locked by this method </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the map ID was successfully set; false, otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9736c0a90ec57e51b3415ef787de861"></a><!-- doxytag: member="ArMapInterface::getReadFileStat" ref="b9736c0a90ec57e51b3415ef787de861" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual struct stat ArMapInterface::getReadFileStat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [read, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns information about the map file that was read. 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. 
<p>Implemented in <a class="el" href="classArMap.html#0413938cf922ff7f52e31b42fbbabfee">ArMap</a>, and <a class="el" href="classArMapSimple.html#a4905db6761bbdad452da8e08f1ca871">ArMapSimple</a>.</p>

</div>
</div><p>
<a class="anchor" name="33d5f7c640ead8c14268379b35d5cbe0"></a><!-- doxytag: member="ArMapInterface::getRemainder" ref="33d5f7c640ead8c14268379b35d5cbe0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt;<a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&gt;* ArMapInterface::getRemainder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of the map file lines that were not recognized. 
<p>
Ideally, the returned list should be empty. The remainder list is primarily used to determine whether the editor is up-to-date for the current map version and to try to minimize lost data.<p>
Note that this method returns a pointer to the actual list that is stored in the map object. It is not safe to store this pointer.<p>
This method is not thread-safe. 
</div>
</div><p>
<a class="anchor" name="f1c75dac69881ba57ffd7826dd600a32"></a><!-- doxytag: member="ArMapInterface::getScanTypes" ref="f1c75dac69881ba57ffd7826dd600a32" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt;std::string&gt; ArMapInterface::getScanTypes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of the scan types that are defined for this map. 
<p>
This method is not thread-safe.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>std::list&lt;std::string&gt; a list of the scan types that are defined for this map </dd></dl>

</div>
</div><p>
<a class="anchor" name="660969c77405c2795a47ce58f0625977"></a><!-- doxytag: member="ArMapInterface::isLoadingDataStarted" ref="660969c77405c2795a47ce58f0625977" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::isLoadingDataStarted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This value returns true once the first DATA tag has been reached. The rest of the map contains data points. 
</div>
</div><p>
<a class="anchor" name="6d2628ce711c2d6774746586932f7913"></a><!-- doxytag: member="ArMapInterface::isLoadingLinesAndDataStarted" ref="6d2628ce711c2d6774746586932f7913" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::isLoadingLinesAndDataStarted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This value returns true once the first LINES tag has been reached. The rest of the map contains data lines and points. 
</div>
</div><p>
<a class="anchor" name="00f12f15367b9c97592b0f45fda2fc2f"></a><!-- doxytag: member="ArMapInterface::mapChanged" ref="00f12f15367b9c97592b0f45fda2fc2f" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::mapChanged           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that will call the map changed CBs if needed. 
<p>
Users of <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> maps should invoke this method after making any changes to the map. It causes the installed map changed handlers to be invoked.<p>
This method is not thread-safe. It should be surrounded by calls to <a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a>. For example:<p>
<code> std::list&lt;ArMapObject*&gt; newMapObjects; // Add some objects... myMap-&gt;<a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>; myMap-&gt;setMapObjects(&amp;newMapObjects); myMap-&gt;<a class="el" href="classArMapInterface.html#00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a>; myMap-&gt;<a class="el" href="classArMapInterface.html#0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a>; </code><p>
Note that this method is automatically invoked under some circumstances (such as when the map file is re-read following a change to the robot configuration). Also note that this method will not invoke any callbacks if the map has not been modified via an explicit call to a set method.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMapInterface.html#00d82761b4bf3a9f6402a7a1696aa8fd" title="Adds a callback that is invoked when the map has been changed.">addMapChangedCB</a> <p>
<a class="el" href="classArMapInterface.html#2ef2626f03eaccdafeb53d93cd2a443c" title="Adds a callback called before the map changed callbacks are called.">addPreMapChangedCB</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a5270bda8f803df83079940ac6e15e5"></a><!-- doxytag: member="ArMapInterface::parseLine" ref="7a5270bda8f803df83079940ac6e15e5" args="(char *line)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::parseLine           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a map line. 
<p>
Public for ArQMapProducer 
</div>
</div><p>
<a class="anchor" name="9ec33c9ef77c8d6fcd6f68b33d0385d9"></a><!-- doxytag: member="ArMapInterface::readFile" ref="9ec33c9ef77c8d6fcd6f68b33d0385d9" args="(const char *fileName, char *errorBuffer=NULL, size_t errorBufferLen=0, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::readFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errorBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>errorBufferLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>md5DigestBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>md5DigestBufferLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the map from the specified file. 
<p>
If the file is successfully read into the map, then this method calls <a class="el" href="classArMapInterface.html#00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> afterwards to invoke the installed callbacks.<p>
This method automatically calls <a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a> during operation. Do not call this method if the map is already locked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>the name of the file to read; Unless an absolute path to a file is given (starting with "/" or "\" or, on Windows, a drive letter root such as "C:\", "D:\", etc.), it is combined with this map's base directory (see <a class="el" href="classArMapInterface.html#6a75aadc1642ea9f8f6004c09fa94306" title="Gets the base directory.">getBaseDirectory()</a>) to form the complete file path name; must be non-NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorBuffer</em>&nbsp;</td><td>a pointer to a char buffer in which specific read errors can be recorded; if NULL, then the return value is the only success indication </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorBufferLen</em>&nbsp;</td><td>the size_t of the error buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>md5DigestBuffer</em>&nbsp;</td><td>an optional pointer to a buffer in which to store the calculated checksum of the map; if NULL, then the checksum is not output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>md5DigestBufferLen</em>&nbsp;</td><td>the size_t of the checksum buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the file was successfully read and the map was populated; false if an error occurred </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors...">ArMD5Calculator</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMap.html#41309477c89bc6ee5a8c90c46cc3ab5b">ArMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="412f9906797ed2e34e6d4589033e3d80"></a><!-- doxytag: member="ArMapInterface::refresh" ref="412f9906797ed2e34e6d4589033e3d80" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::refresh           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the map file needs to be re-read. 
<p>
This method is primarily applicable to the active <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that is associated with the robot configuration. It checks to see if the map file has been modified since it was read, and re-reads it if necessary. The method may do nothing for "simpler" maps. 
</div>
</div><p>
<a class="anchor" name="65da492e1379f9a9d226b552a2be65d3"></a><!-- doxytag: member="ArMapInterface::remMapChangedCB" ref="65da492e1379f9a9d226b552a2be65d3" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remMapChangedCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a callback called when the map has been changed. 
<p>
This method is not thread-safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="80f3ea46ca3969d4eaf6253b39c84f5c"></a><!-- doxytag: member="ArMapInterface::remPostWriteFileCB" ref="80f3ea46ca3969d4eaf6253b39c84f5c" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPostWriteFileCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the given callback from the list of post-write callbacks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> * callback to be removed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0563d1953c0795a0ee85ebb2a7c9b13c"></a><!-- doxytag: member="ArMapInterface::remPreMapChangedCB" ref="0563d1953c0795a0ee85ebb2a7c9b13c" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPreMapChangedCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the specified "pre-map-changed callback". 
<p>
This method is not thread-safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44fbadba38009509c473ca622a59b8b1"></a><!-- doxytag: member="ArMapInterface::remPreWriteFileCB" ref="44fbadba38009509c473ca622a59b8b1" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::remPreWriteFileCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td>
          <td class="paramname"> <em>functor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the given callback from the list of pre-write callbacks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>the <a class="el" href="classArFunctor.html" title="Base class for functors.">ArFunctor</a> * callback to be removed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20061ab5be4b9b469a7221ca12fdd9be"></a><!-- doxytag: member="ArMapInterface::set" ref="20061ab5be4b9b469a7221ca12fdd9be" args="(ArMapInterface *other)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArMapInterface.html">ArMapInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets this map to be "equivalent" to the given other map. 
<p>
Modifies this map so that is effectively a copy of the given map. All info, objects, and data points and lines in the other map are copied and stored in this map. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArMapInterface.html">ArMapInterface</a> to be copied; must not be NULL </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the map was successfully copied to this one; false if an error occurred </dd></dl>

</div>
</div><p>
<a class="anchor" name="60ca7573c074769719b00c3c96ec17c4"></a><!-- doxytag: member="ArMapInterface::setIgnoreCase" ref="60ca7573c074769719b00c3c96ec17c4" args="(bool ignoreCase=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::setIgnoreCase           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreCase</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether we ignore case or not. 
<p>
This method is primarily applicable to the active <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that is associated with the robot configuration. 
</div>
</div><p>
<a class="anchor" name="a65367c7823f46fdae42d53f201699a5"></a><!-- doxytag: member="ArMapInterface::setIgnoreEmptyFileName" ref="a65367c7823f46fdae42d53f201699a5" args="(bool ignore)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::setIgnoreEmptyFileName           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignore</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether we ignore empty file names or fail if we encounter one. 
<p>
This method is primarily applicable to the active <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map that is associated with the robot configuration. 
</div>
</div><p>
<a class="anchor" name="cac90c5ce18a25ecd6d08ce8116a27aa"></a><!-- doxytag: member="ArMapInterface::setMapObjectParams" ref="cac90c5ce18a25ecd6d08ce8116a27aa" args="(const char *mapObjectName, ArArgumentBuilder *params, ArMapChangeDetails *changeDetails=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::setMapObjectParams           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mapObjectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *&nbsp;</td>
          <td class="paramname"> <em>changeDetails</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the optional parameters associated with a map object. 
<p>
This method sets the parameter values for the specified map object. It should be used only for custom map object types that have a parameter list defined in the MapInfo. (Refer to the <a class="el" href="classArMap.html" title="A map of a space the robot can navigate within, and which can be updated via the...">ArMap</a> MapFileFormat for more information.)<p>
Like <a class="el" href="classArMapInterface.html#69999157a3713d4ada7d47f6a3087b73" title="Returns the optional parameters associated with a map object, or NULL if none.">findMapObjectParams()</a>, this is basically a convenience method that simplifies access to the data stored in the CairnInfo argument list.<p>
If the given params is non-NULL, then it is copied and stored in the map. (Note that this deletes the pointer previously returned by findMapObjectParams(mapObjectName). Do not store that pointer.) It is entirely the caller's responsibility to ensure that the params arg count and types are correct.<p>
If the given params is NULL, then the parameter information for the map object is cleared. If a mapObjectWithParams is to be deleted, then setMapObjectParams(mapObjectWithParams-&gt;getName(), NULL) must be called first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapObjectName</em>&nbsp;</td><td>the unique char * name of the map object whose parameters are to be updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>the ArArgumentBuiler * containing the new parameter values; if NULL, then the parameter information for the map object is deleted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>changeDetails</em>&nbsp;</td><td>an optional pointer to the <a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> in which to accumulate a description of the changes to the map; if NULL, then changes are not tracked </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMapSimple.html#9b3beb8b640bec38f6db16c63fd11232">ArMapSimple</a>.</p>

</div>
</div><p>
<a class="anchor" name="c519568cc0d2e3a87d4e7feabf04a7aa"></a><!-- doxytag: member="ArMapInterface::setScanTypes" ref="c519568cc0d2e3a87d4e7feabf04a7aa" args="(const std::list&lt; std::string &gt; &amp;scanTypeList)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::setScanTypes           </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>scanTypeList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the scan types that are defined for this map. 
<p>
This method clears all of the exisiting scans (i.e. point and line data). This method is not thread-safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanTypeList</em>&nbsp;</td><td>the list of scan type string identifiers to be set; the list must not contain any duplicate entries </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the scan types were successfully set; false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc9644192ab38bd3b8a019d6e910ef42"></a><!-- doxytag: member="ArMapInterface::setSourceFileName" ref="dc9644192ab38bd3b8a019d6e910ef42" args="(const char *sourceName, const char *fileName, bool isInternalCall=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::setSourceFileName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isInternalCall</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the name of the source and the file from which the map was loaded. 
<p>
This method is primarily used to track when a map has been received from the central server or another robot. The source and file name can be retrieved from the map ID. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceName</em>&nbsp;</td><td>the const char * name of the central server or robot from which the map was obtained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>the const char * name of the map file on the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isInternalCall</em>&nbsp;</td><td>a bool set to true if this method is being called while the map is locked; if false, then this method will lock the map </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de2aaba8c0a991964c2a623987a589fe"></a><!-- doxytag: member="ArMapInterface::writeFile" ref="de2aaba8c0a991964c2a623987a589fe" args="(const char *fileName, bool internalCall=false, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0, time_t fileTimestamp=-1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapInterface::writeFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>internalCall</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>md5DigestBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>md5DigestBufferLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>fileTimestamp</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the map to the specified file. 
<p>
By default, this method automatically calls <a class="el" href="classArMapInterface.html#2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a> during its operation. If the map is already locked when the file needs to be written, then set the internalCall parameter to true to override the default locking behavior<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>the const char * name of the file to written; it is combined with the <a class="el" href="classArMapInterface.html#6a75aadc1642ea9f8f6004c09fa94306" title="Gets the base directory.">getBaseDirectory()</a> to form the complete file path name; must be non-NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>internalCall</em>&nbsp;</td><td>a bool set to true if writeFile is being called while the map is already locked; set to false to indicate that the map should lock itself during the method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>md5DigestBuffer</em>&nbsp;</td><td>an optional pointer to a buffer in which to store the calculated checksum of the map; if NULL, then the checksum is not output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>md5DigestBufferLen</em>&nbsp;</td><td>the size_t of the checksum buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileTimestamp</em>&nbsp;</td><td>the time_t to which to set the file write time; in general, this should be left as -1 to indicate that the actual write time is desired; a real time value can be used to synchronize the map across many robots </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the file was successfully written; false if an error occurred </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors...">ArMD5Calculator</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMap.html#3922ae9a351c1739a24d9247f7db1cc5">ArMap</a>.</p>

</div>
</div><p>
<a class="anchor" name="bc4e372308bbf06195dea3c0bccc93b8"></a><!-- doxytag: member="ArMapInterface::writeObjectsToFunctor" ref="bc4e372308bbf06195dea3c0bccc93b8" args="(ArFunctor1&lt; const char * &gt; *functor, const char *endOfLineChars, bool isOverrideAsSingleScan=false, const char *maxCategory=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::writeObjectsToFunctor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>endOfLineChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isOverrideAsSingleScan</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>maxCategory</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the map header information and objects to a text-based functor. 
<p>
This method writes all of the map scan headers, the info arguments, and the Cairn map objects to the given functor. It does not write the actual scan point or line segment data (nor the header lines that introduce the data). This method is not thread-safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the map header as text lines </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endOfLineChars</em>&nbsp;</td><td>the const char * string to use as an end-of-line indicator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isOverrideAsSingleScan</em>&nbsp;</td><td>a bool set to true if only a single scan header should be written; this is generally the "summary scan" and is used to maintain backwards compatibility with client applications that do not expect multiple scan types in a single map. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4721211e839289dc8ab24202e07471cc"></a><!-- doxytag: member="ArMapInterface::writeToFunctor" ref="4721211e839289dc8ab24202e07471cc" args="(ArFunctor1&lt; const char * &gt; *functor, const char *endOfLineChars)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapInterface::writeToFunctor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>endOfLineChars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes all of the map to the given text-based functor. 
<p>
This method is not thread-safe <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the map header as text lines </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endOfLineChars</em>&nbsp;</td><td>the const char * string to use as an end-of-line indicator </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ArMapInterface_8h.html">ArMapInterface.h</a><li>ArMapInterface.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 1 12:22:51 2012 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
