<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Aria: ArSocket Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ArSocket Class Reference</h1><!-- doxytag: class="ArSocket" --><code>#include &lt;ArSocket.h&gt;</code>
<p>

<p>
<a href="classArSocket-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
socket communication wrapper 
<p>
<a class="el" href="classArSocket.html" title="socket communication wrapper">ArSocket</a> is a layer which allows you to use the sockets networking interface in an operating system independent manner. All of the standard commonly used socket functions are implemented such as <a class="el" href="classArSocket.html#7a9bd59b92bd1018c8be0af39eac2dc8">open()</a>, <a class="el" href="classArSocket.html#89ab9a4e404526343ccf6ba3b6644c58" title="Close the socket.">close()</a>, <a class="el" href="classArSocket.html#e9d803dcf9ad0bb72b790d3098ca8dc5" title="Connect as a client to a server.">connect()</a>, <a class="el" href="classArSocket.html#6647efb8d20f9523dad090a68b1e4e2c" title="Accept a new connection.">accept()</a>, <a class="el" href="classArSocket.html#6cf324be0075d3469a70d01d4740e23c" title="Read data from the socket.">read()</a>, <a class="el" href="classArSocket.html#f2cfbd564eec7020283f5a6fe41f558f" title="Write data to the socket.">write()</a>, <a class="el" href="classArSocket.html#f081e418282cd9d9cc72672808b9ce9d" title="Convert an int from host byte order to network byte order.">hostToNetOrder()</a>, <a class="el" href="classArSocket.html#fd267582a359ab24bdfd04ef12f211c9" title="Convert an int from network byte order to host byte order.">netToHostOrder()</a>. <a class="el" href="classArSocket.html" title="socket communication wrapper">ArSocket</a> extends some of these functions to set useful options (see method documentation for details). It also provides additional useful functions like <a class="el" href="classArSocket.html#62c1a96eb8fa0dd1c384646228eac194" title="Writes a string to the socket (adding end of line characters).">writeString()</a>, readString, <a class="el" href="classArSocket.html#00d3639bbd69a3b15a0a2d1bb18926ae" title="Sets the callback for when the socket is closed (nicely or harshly).">setCloseCallback()</a>, and more.<p>
In Windows, the sockets subsystem needs to be initialized and shutdown by the program. So when a program starts it must call <a class="el" href="classAria.html#d99c16b5d947229d9f8e1c5b2d4cdd73" title="Initialize Aria global data struture and perform OS-specific initialization, including...">Aria::init()</a> and call <a class="el" href="classAria.html#184602a2b3799d61569ec55dd9508450" title="Shutdown all Aria processes/threads.">Aria::shutdown()</a> when it exits. (Or, to only initialize the socket system, and not do any other global <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> initialization, use <a class="el" href="classArSocket.html#11b42725ca91a9d95cbe85f56feba58e" title="Initialize the OS sockets system, if neccesary.">ArSocket::init()</a> and <a class="el" href="classArSocket.html#ec8534984137fb13a4f1e94c2b3839dc" title="Shutdown the OS sockets system, if neccesary.">ArSocket::shutdown()</a>.)<p>
Some calls set an error code on failure in addition to returning false. This value is available from <a class="el" href="classArSocket.html#a7fa3b38b159dfca7b2fe9a49cb78fde" title="Get a code representing the last error.">getError()</a>. If <a class="el" href="classArSocket.html#a7fa3b38b159dfca7b2fe9a49cb78fde" title="Get a code representing the last error.">getError()</a> returns something other than NoErr, a text description of the error may be available from <a class="el" href="classArSocket.html#940299aab2087e9247dece7b7fe01a5c" title="Get a string containing a description of the last error. Only valid if getError()...">getErrorStr()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="socketServerExample_8cpp-example.html">socketServerExample::cpp</a> <p>
<a class="el" href="socketClientExample_8cpp-example.html">socketClientExample::cpp</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>

<p>
<a class="el" href="netServerExample_8cpp-example.html#_a0">netServerExample.cpp</a>, <a class="el" href="socketClientExample_8cpp-example.html#_a0">socketClientExample.cpp</a>, and <a class="el" href="socketServerExample_8cpp-example.html#_a1">socketServerExample.cpp</a>.</dl><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Error</b> { <br>
&nbsp;&nbsp;<b>NoErr</b>, 
<b>NetFail</b>, 
<b>ConBadHost</b>, 
<b>ConNoRoute</b>, 
<br>
&nbsp;&nbsp;<b>ConRefused</b>, 
<b>NameLookup</b>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Type</b> { <b>UDP</b>, 
<b>TCP</b>, 
<b>Unknown</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#6647efb8d20f9523dad090a68b1e4e2c">accept</a> (<a class="el" href="classArSocket.html">ArSocket</a> *sock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a new connection.  <a href="#6647efb8d20f9523dad090a68b1e4e2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#133fce4174f7a64327353510804796e9">ArSocket</a> (int port, bool doClose, Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor which outomatically opens a server port.  <a href="#133fce4174f7a64327353510804796e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#612acf14e9aca4e12e931784a5147513">ArSocket</a> (const char *host, int port, Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor which automatically connects to a server as a client.  <a href="#612acf14e9aca4e12e931784a5147513"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6e63b642e8fa16034373b51ef1c35705"></a><!-- doxytag: member="ArSocket::ArSocket" ref="6e63b642e8fa16034373b51ef1c35705" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#6e63b642e8fa16034373b51ef1c35705">ArSocket</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77095a410aa628bdb678551ffb7a8dc9"></a><!-- doxytag: member="ArSocket::clearPartialReadString" ref="77095a410aa628bdb678551ffb7a8dc9" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#77095a410aa628bdb678551ffb7a8dc9">clearPartialReadString</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the partial string read. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#89ab9a4e404526343ccf6ba3b6644c58">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the socket.  <a href="#89ab9a4e404526343ccf6ba3b6644c58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="678068d415d94ac8cb24af819b928786"></a><!-- doxytag: member="ArSocket::comparePartialReadString" ref="678068d415d94ac8cb24af819b928786" args="(const char *partialString)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#678068d415d94ac8cb24af819b928786">comparePartialReadString</a> (const char *partialString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares a string against what was partially read. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#e9d803dcf9ad0bb72b790d3098ca8dc5">connect</a> (const char *host, int port, Type type=TCP, const char *openOnIP=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect as a client to a server.  <a href="#e9d803dcf9ad0bb72b790d3098ca8dc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#53c91a81c037e89f8c451ed265664ae9">connectTo</a> (struct sockaddr_in *sin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the socket to the given address.  <a href="#53c91a81c037e89f8c451ed265664ae9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#7264b5996106c967abad8260e416d4d1">connectTo</a> (const char *host, int port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the socket to the given address.  <a href="#7264b5996106c967abad8260e416d4d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0ecc5803161bcb8064355370f229bfd6"></a><!-- doxytag: member="ArSocket::copy" ref="0ecc5803161bcb8064355370f229bfd6" args="(ArSocket *s)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#0ecc5803161bcb8064355370f229bfd6">copy</a> (<a class="el" href="classArSocket.html">ArSocket</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy socket structures. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#933a1ca8492112def78ce9129023fc33">copy</a> (int fd, bool doclose)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy socket structures.  <a href="#933a1ca8492112def78ce9129023fc33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#65d4a673234731800cb0f0fd399f2e2a">create</a> (Type type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simply create a port.  <a href="#65d4a673234731800cb0f0fd399f2e2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#275484e4c9c98f05e61d7427ac3dcac6">findValidPort</a> (int startPort, const char *openOnIP=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce2cdae7d0f720bf806c5c8fd80b6283"></a><!-- doxytag: member="ArSocket::getBadRead" ref="ce2cdae7d0f720bf806c5c8fd80b6283" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ce2cdae7d0f720bf806c5c8fd80b6283">getBadRead</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets if we've had a bad read (you have to use error tracking for this). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e0f6a5a791d9cc67672e72f466a20733"></a><!-- doxytag: member="ArSocket::getBadWrite" ref="e0f6a5a791d9cc67672e72f466a20733" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#e0f6a5a791d9cc67672e72f466a20733">getBadWrite</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets if we've had a bad write (you have to use error tracking for this). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dacaadc3f0a9368f74d28653a51aa64b"></a><!-- doxytag: member="ArSocket::getBytesRecvd" ref="dacaadc3f0a9368f74d28653a51aa64b" args="(void)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#dacaadc3f0a9368f74d28653a51aa64b">getBytesRecvd</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of bytes we've read. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4caa942c5a621f7ae7d6f4e4e791734"></a><!-- doxytag: member="ArSocket::getBytesSent" ref="d4caa942c5a621f7ae7d6f4e4e791734" args="(void)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#d4caa942c5a621f7ae7d6f4e4e791734">getBytesSent</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of bytes we've written. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d6981526f9b4deeea5358d62915cdeb6"></a><!-- doxytag: member="ArSocket::getCloseCallback" ref="d6981526f9b4deeea5358d62915cdeb6" args="(void)" -->
<a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#d6981526f9b4deeea5358d62915cdeb6">getCloseCallback</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the callback for when the socket is closed (nicely or harshly). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="648c510820eda49619a22248915b084b"></a><!-- doxytag: member="ArSocket::getEcho" ref="648c510820eda49619a22248915b084b" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#648c510820eda49619a22248915b084b">getEcho</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets if we are echoing on the readString calls this socket does. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7fa3b38b159dfca7b2fe9a49cb78fde"></a><!-- doxytag: member="ArSocket::getError" ref="a7fa3b38b159dfca7b2fe9a49cb78fde" args="() const " -->
Error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#a7fa3b38b159dfca7b2fe9a49cb78fde">getError</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a code representing the last error. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="940299aab2087e9247dece7b7fe01a5c"></a><!-- doxytag: member="ArSocket::getErrorStr" ref="940299aab2087e9247dece7b7fe01a5c" args="() const " -->
const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#940299aab2087e9247dece7b7fe01a5c">getErrorStr</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a string containing a description of the last error. Only valid if <a class="el" href="classArSocket.html#a7fa3b38b159dfca7b2fe9a49cb78fde" title="Get a code representing the last error.">getError()</a> does not return NoErr. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89aeefed86ac695e62480ec8e301f7dd"></a><!-- doxytag: member="ArSocket::getErrorTracking" ref="89aeefed86ac695e62480ec8e301f7dd" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#89aeefed86ac695e62480ec8e301f7dd">getErrorTracking</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether we're doing error tracking or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f083363003397e042900e745da00a56"></a><!-- doxytag: member="ArSocket::getFD" ref="6f083363003397e042900e745da00a56" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#6f083363003397e042900e745da00a56">getFD</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa6688b1776c58956b5d77e5b4933ebf"></a><!-- doxytag: member="ArSocket::getIPString" ref="aa6688b1776c58956b5d77e5b4933ebf" args="(void) const " -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#aa6688b1776c58956b5d77e5b4933ebf">getIPString</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the ip number as a string (this can be modified though). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="419d5c27368a73c3c2e794fdf198d280"></a><!-- doxytag: member="ArSocket::getLastStringReadTime" ref="419d5c27368a73c3c2e794fdf198d280" args="(void)" -->
<a class="el" href="classArTime.html">ArTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#419d5c27368a73c3c2e794fdf198d280">getLastStringReadTime</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the time we last successfully read a string from the socket. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15522e90c684f87d35e82d206edb2615"></a><!-- doxytag: member="ArSocket::getLogWriteStrings" ref="15522e90c684f87d35e82d206edb2615" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#15522e90c684f87d35e82d206edb2615">getLogWriteStrings</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether we log the writeStrings or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5522159a0fa067bb20ad5dfb271d4e87"></a><!-- doxytag: member="ArSocket::getRawIPString" ref="5522159a0fa067bb20ad5dfb271d4e87" args="(void) const " -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#5522159a0fa067bb20ad5dfb271d4e87">getRawIPString</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw ip number as a string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="450f731d0774186d6029425f36e2867e"></a><!-- doxytag: member="ArSocket::getRecvs" ref="450f731d0774186d6029425f36e2867e" args="(void)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#450f731d0774186d6029425f36e2867e">getRecvs</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of reads we've done. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8bd089aedbebfd7492efabd66128b982"></a><!-- doxytag: member="ArSocket::getSends" ref="8bd089aedbebfd7492efabd66128b982" args="(void)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#8bd089aedbebfd7492efabd66128b982">getSends</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of writes we've done. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#e8bf1dbbb2aaecf96d23a13e68f68032">getSockName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get socket information (socket "name"). Aspects of this "name" are accessible with <a class="el" href="classArSocket.html#927ee1fa6eace33c6338f2644a614513" title="Accessor for the sockaddr.">sockAddrIn()</a>, <a class="el" href="classArSocket.html#8145c15c517a8be617630b22b854c4f4" title="Accessor for the in_addr part of sockaddr.">inAddr()</a>, <a class="el" href="classArSocket.html#34005874b46b174cfff549bcd8f50958" title="Accessor for the port of the sockaddr.">inPort()</a>.  <a href="#e8bf1dbbb2aaecf96d23a13e68f68032"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1fa3014f97e7f63a750f09233910dba9"></a><!-- doxytag: member="ArSocket::getStringUseWrongEndChars" ref="1fa3014f97e7f63a750f09233910dba9" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#1fa3014f97e7f63a750f09233910dba9">getStringUseWrongEndChars</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether we log the writeStrings or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d367e1ccbe8b88b1049f75d2d9c31973"></a><!-- doxytag: member="ArSocket::getType" ref="d367e1ccbe8b88b1049f75d2d9c31973" args="() const " -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#d367e1ccbe8b88b1049f75d2d9c31973">getType</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the protocol type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8145c15c517a8be617630b22b854c4f4"></a><!-- doxytag: member="ArSocket::inAddr" ref="8145c15c517a8be617630b22b854c4f4" args="()" -->
struct in_addr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#8145c15c517a8be617630b22b854c4f4">inAddr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the in_addr part of sockaddr. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34005874b46b174cfff549bcd8f50958"></a><!-- doxytag: member="ArSocket::inPort" ref="34005874b46b174cfff549bcd8f50958" args="()" -->
unsigned short int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#34005874b46b174cfff549bcd8f50958">inPort</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the port of the sockaddr. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0ea5b772014e84038b11007c784aa80"></a><!-- doxytag: member="ArSocket::isOpen" ref="f0ea5b772014e84038b11007c784aa80" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isOpen</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#7a9bd59b92bd1018c8be0af39eac2dc8">open</a> (int port, Type type, const char *openOnIP=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#6cf324be0075d3469a70d01d4740e23c">read</a> (void *buff, size_t len, unsigned int msWait=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from the socket.  <a href="#6cf324be0075d3469a70d01d4740e23c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#7a6449d5b385d44e26af4250eaf7658c">readString</a> (unsigned int msWait=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a string from the socket.  <a href="#7a6449d5b385d44e26af4250eaf7658c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#5b1623bf035093715ab90af1677ce2f2">recvFrom</a> (void *msg, int len, sockaddr_in *sin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message (short string) from the socket.  <a href="#5b1623bf035093715ab90af1677ce2f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6623e8121740f86d339678bd374a64e"></a><!-- doxytag: member="ArSocket::resetTracking" ref="e6623e8121740f86d339678bd374a64e" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#e6623e8121740f86d339678bd374a64e">resetTracking</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the tracking information on the socket. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#7aa35f485bbdbacfe599617366d761ff">sendTo</a> (const void *msg, int len, struct sockaddr_in *sin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message (short string) on the socket.  <a href="#7aa35f485bbdbacfe599617366d761ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ad4e9284aa39028d770a6fef0ebb62a3">sendTo</a> (const void *msg, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message (short string) on the socket.  <a href="#ad4e9284aa39028d770a6fef0ebb62a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#946caf0804f5d91682d816d0995c84c2">setBroadcast</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set broadcast value.  <a href="#946caf0804f5d91682d816d0995c84c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00d3639bbd69a3b15a0a2d1bb18926ae"></a><!-- doxytag: member="ArSocket::setCloseCallback" ref="00d3639bbd69a3b15a0a2d1bb18926ae" args="(ArFunctor *functor)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#00d3639bbd69a3b15a0a2d1bb18926ae">setCloseCallback</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the callback for when the socket is closed (nicely or harshly). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee8af0ae8cda0d42af53b0d947f63662"></a><!-- doxytag: member="ArSocket::setDoClose" ref="ee8af0ae8cda0d42af53b0d947f63662" args="(bool yesno)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ee8af0ae8cda0d42af53b0d947f63662">setDoClose</a> (bool yesno)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the doClose value. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="88ff816474b10a1ff7d5e1e6f669ad0b"></a><!-- doxytag: member="ArSocket::setEcho" ref="88ff816474b10a1ff7d5e1e6f669ad0b" args="(bool echo)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#88ff816474b10a1ff7d5e1e6f669ad0b">setEcho</a> (bool echo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets echoing on the readString calls this socket does. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51f2ffe292d3e8aa8cf2dbc3616b4fdc"></a><!-- doxytag: member="ArSocket::setErrorTracking" ref="51f2ffe292d3e8aa8cf2dbc3616b4fdc" args="(bool errorTracking)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#51f2ffe292d3e8aa8cf2dbc3616b4fdc">setErrorTracking</a> (bool errorTracking)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether we're error tracking or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1ce133ca58c9f8277cdbce80aa04241"></a><!-- doxytag: member="ArSocket::setIPString" ref="e1ce133ca58c9f8277cdbce80aa04241" args="(const char *ipString)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#e1ce133ca58c9f8277cdbce80aa04241">setIPString</a> (const char *ipString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ip string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ee3f81f6d774f883b1ff46fe9d89d02f">setLinger</a> (int time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the linger value.  <a href="#ee3f81f6d774f883b1ff46fe9d89d02f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b44fe448b57e7730a049e62464760b5"></a><!-- doxytag: member="ArSocket::setLogWriteStrings" ref="4b44fe448b57e7730a049e62464760b5" args="(bool logWriteStrings)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#4b44fe448b57e7730a049e62464760b5">setLogWriteStrings</a> (bool logWriteStrings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether we log the writeStrings or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#5c435287e6e2f778874dcc15c6aa4e27">setNoDelay</a> (bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets NODELAY option on TCP socket, which can reduce latency for small packet sizes.  <a href="#5c435287e6e2f778874dcc15c6aa4e27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#657700645f097c3b53c2f5bb8c97cb7e">setNonBlock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket to nonblocking. Most importantly, calls to <a class="el" href="classArSocket.html#6cf324be0075d3469a70d01d4740e23c" title="Read data from the socket.">read()</a> will return immediately, even if no data is available.  <a href="#657700645f097c3b53c2f5bb8c97cb7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83885cf24c725497489d10cf68dcc264"></a><!-- doxytag: member="ArSocket::setReadStringIgnoreReturn" ref="83885cf24c725497489d10cf68dcc264" args="(bool ignore)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#83885cf24c725497489d10cf68dcc264">setReadStringIgnoreReturn</a> (bool ignore)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to ignore carriage return characters in readString or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#87e6aaf36163f42cac218333ecc078b7">setReuseAddress</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the reuse address value.  <a href="#87e6aaf36163f42cac218333ecc078b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4a311d9c20b378cf65a2f8c0bb45158"></a><!-- doxytag: member="ArSocket::setStringUseWrongEndChars" ref="f4a311d9c20b378cf65a2f8c0bb45158" args="(bool useWrongEndChars)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#f4a311d9c20b378cf65a2f8c0bb45158">setStringUseWrongEndChars</a> (bool useWrongEndChars)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether we use the wrong (legacy) end chars or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="927ee1fa6eace33c6338f2644a614513"></a><!-- doxytag: member="ArSocket::sockAddrIn" ref="927ee1fa6eace33c6338f2644a614513" args="()" -->
struct sockaddr_in *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#927ee1fa6eace33c6338f2644a614513">sockAddrIn</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the sockaddr. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#a92f0db004d5642efb4298e4fcad2738">transfer</a> (<a class="el" href="classArSocket.html">ArSocket</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer ownership of a socket.  <a href="#a92f0db004d5642efb4298e4fcad2738"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#f2cfbd564eec7020283f5a6fe41f558f">write</a> (const void *buff, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to the socket.  <a href="#f2cfbd564eec7020283f5a6fe41f558f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#62c1a96eb8fa0dd1c384646228eac194">writeString</a> (const char *str,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a string to the socket (adding end of line characters).  <a href="#62c1a96eb8fa0dd1c384646228eac194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="69ca55d1e3007e2743c53b038bbe62a7"></a><!-- doxytag: member="ArSocket::writeStringPlain" ref="69ca55d1e3007e2743c53b038bbe62a7" args="(const char *str)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#69ca55d1e3007e2743c53b038bbe62a7">writeStringPlain</a> (const char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classArSocket.html#62c1a96eb8fa0dd1c384646228eac194" title="Writes a string to the socket (adding end of line characters).">writeString()</a>, but no varargs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a646555713d800087963735c3aa55b5"></a><!-- doxytag: member="ArSocket::~ArSocket" ref="9a646555713d800087963735c3aa55b5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#9a646555713d800087963735c3aa55b5">~ArSocket</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#666b81136fa241062dfdc4aff63913f3">addrHost</a> (struct in_addr &amp;addr, char *host)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert an address structure to a hostname string.  <a href="#666b81136fa241062dfdc4aff63913f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2bfb5761883c6306a3c22b90180ad36"></a><!-- doxytag: member="ArSocket::getHostName" ref="c2bfb5761883c6306a3c22b90180ad36" args="()" -->
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#c2bfb5761883c6306a3c22b90180ad36">getHostName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the localhost address. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#a11d9c51e510e4b7bfc35103bc3b4114">hostAddr</a> (const char *host, struct in_addr &amp;addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a hostname string to an address structure.  <a href="#a11d9c51e510e4b7bfc35103bc3b4114"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f081e418282cd9d9cc72672808b9ce9d"></a><!-- doxytag: member="ArSocket::hostToNetOrder" ref="f081e418282cd9d9cc72672808b9ce9d" args="(int i)" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#f081e418282cd9d9cc72672808b9ce9d">hostToNetOrder</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert an int from host byte order to network byte order. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#11b42725ca91a9d95cbe85f56feba58e">init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the OS sockets system, if neccesary.  <a href="#11b42725ca91a9d95cbe85f56feba58e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b26ab367da522f4e388cbba5e55438bb"></a><!-- doxytag: member="ArSocket::inToA" ref="b26ab367da522f4e388cbba5e55438bb" args="(struct in_addr *addr, char *buff)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#b26ab367da522f4e388cbba5e55438bb">inToA</a> (struct in_addr *addr, char *buff)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert <em>addr</em> into string numerical address. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4c5eb5dc6183eb692867399acc1d024"></a><!-- doxytag: member="ArSocket::maxHostNameLen" ref="d4c5eb5dc6183eb692867399acc1d024" args="()" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#d4c5eb5dc6183eb692867399acc1d024">maxHostNameLen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max host name length. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd267582a359ab24bdfd04ef12f211c9"></a><!-- doxytag: member="ArSocket::netToHostOrder" ref="fd267582a359ab24bdfd04ef12f211c9" args="(int i)" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#fd267582a359ab24bdfd04ef12f211c9">netToHostOrder</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert an int from network byte order to host byte order. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ec8534984137fb13a4f1e94c2b3839dc">shutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the OS sockets system, if neccesary.  <a href="#ec8534984137fb13a4f1e94c2b3839dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac70285e1c71e39c730354779aad930f"></a><!-- doxytag: member="ArSocket::sockAddrLen" ref="ac70285e1c71e39c730354779aad930f" args="()" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ac70285e1c71e39c730354779aad930f">sockAddrLen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the sockaddr. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3dabc6bfbee605d1c4ed786251c2487e"></a><!-- doxytag: member="ArSocket::toString" ref="3dabc6bfbee605d1c4ed786251c2487e" args="(Type t)" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#3dabc6bfbee605d1c4ed786251c2487e">toString</a> (Type t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the given socket type to a displayable text string (for debugging). <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca573cdd6accf8b1a4597144d11caf7a"></a><!-- doxytag: member="ArSocket::ourInitialized" ref="ca573cdd6accf8b1a4597144d11caf7a" args="" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#ca573cdd6accf8b1a4597144d11caf7a">ourInitialized</a> = true</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We're always initialized in Linux. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02c8cf76da42735513ed16f337d7995c"></a><!-- doxytag: member="ArSocket::doStringEcho" ref="02c8cf76da42735513ed16f337d7995c" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#02c8cf76da42735513ed16f337d7995c">doStringEcho</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal function that echos strings from read string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14db81375c1a585fd01c5bf9c6aedf98"></a><!-- doxytag: member="ArSocket::internalInit" ref="14db81375c1a585fd01c5bf9c6aedf98" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>internalInit</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e434e97f4a1fa1468f501ac1a107a960"></a><!-- doxytag: member="ArSocket::separateHost" ref="e434e97f4a1fa1468f501ac1a107a960" args="(const char *rawHost, int rawPort, char *useHost, size_t useHostSize, int *port)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>separateHost</b> (const char *rawHost, int rawPort, char *useHost, size_t useHostSize, int *port)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSocket.html#91f2b1736eefe5a0aa68664473a1bef5">setRawIPString</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fcce4cd18c1628db9e325eac3db91dc9"></a><!-- doxytag: member="ArSocket::myBadRead" ref="fcce4cd18c1628db9e325eac3db91dc9" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myBadRead</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57d3ceba19d8be1693261ca56bb4ad17"></a><!-- doxytag: member="ArSocket::myBadWrite" ref="57d3ceba19d8be1693261ca56bb4ad17" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myBadWrite</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a6a040b43588c7516f9ffdfd0925b7e"></a><!-- doxytag: member="ArSocket::myBytesRecvd" ref="9a6a040b43588c7516f9ffdfd0925b7e" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>myBytesRecvd</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de93541f345978b63ead59f2df03e0a3"></a><!-- doxytag: member="ArSocket::myBytesSent" ref="de93541f345978b63ead59f2df03e0a3" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>myBytesSent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27b9b67047464c5c63746da87aa1ab75"></a><!-- doxytag: member="ArSocket::myCloseFunctor" ref="27b9b67047464c5c63746da87aa1ab75" args="" -->
<a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCloseFunctor</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ea6265ce63a8be89c0c5ec9aba5c775"></a><!-- doxytag: member="ArSocket::myDoClose" ref="6ea6265ce63a8be89c0c5ec9aba5c775" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myDoClose</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60119bd4625c2377b4102ccdf671f0e5"></a><!-- doxytag: member="ArSocket::myError" ref="60119bd4625c2377b4102ccdf671f0e5" args="" -->
Error&nbsp;</td><td class="memItemRight" valign="bottom"><b>myError</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a161e749683fae496989f793fb099641"></a><!-- doxytag: member="ArSocket::myErrorStr" ref="a161e749683fae496989f793fb099641" args="" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myErrorStr</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c0f025762342dc33e85a96736d35ea8c"></a><!-- doxytag: member="ArSocket::myErrorTracking" ref="c0f025762342dc33e85a96736d35ea8c" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myErrorTracking</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f179465ed45ab4e6e31dd5b6009bfdc"></a><!-- doxytag: member="ArSocket::myFD" ref="1f179465ed45ab4e6e31dd5b6009bfdc" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myFD</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="036a9a049ca89668c4f2131d829f9532"></a><!-- doxytag: member="ArSocket::myIPString" ref="036a9a049ca89668c4f2131d829f9532" args="" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myIPString</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a625f78aaacdc387b1d7fb896b66f891"></a><!-- doxytag: member="ArSocket::myLastStringReadTime" ref="a625f78aaacdc387b1d7fb896b66f891" args="" -->
<a class="el" href="classArTime.html">ArTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myLastStringReadTime</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4369435b4b775c73154aeb9631b8cef"></a><!-- doxytag: member="ArSocket::myLogWriteStrings" ref="e4369435b4b775c73154aeb9631b8cef" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myLogWriteStrings</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b703361b7349afe18e186a16372f27d"></a><!-- doxytag: member="ArSocket::myNonBlocking" ref="3b703361b7349afe18e186a16372f27d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myNonBlocking</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23ff60dc6d70cea35cb060fc88fad2f1"></a><!-- doxytag: member="ArSocket::myRawIPString" ref="23ff60dc6d70cea35cb060fc88fad2f1" args="[128]" -->
char&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRawIPString</b> [128]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="394365f59801d71402749de9fd55d2f3"></a><!-- doxytag: member="ArSocket::myReadStringMutex" ref="394365f59801d71402749de9fd55d2f3" args="" -->
<a class="el" href="classArMutex.html">ArMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myReadStringMutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2b4e91f59c064b1a279882e48ee31d9b"></a><!-- doxytag: member="ArSocket::myRecvs" ref="2b4e91f59c064b1a279882e48ee31d9b" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRecvs</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="792de5f964cbf9cd2151bf574a5e0518"></a><!-- doxytag: member="ArSocket::mySends" ref="792de5f964cbf9cd2151bf574a5e0518" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>mySends</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f97d94b49e2cca8727957f35b4f1b16"></a><!-- doxytag: member="ArSocket::mySin" ref="2f97d94b49e2cca8727957f35b4f1b16" args="" -->
struct sockaddr_in&nbsp;</td><td class="memItemRight" valign="bottom"><b>mySin</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24447d6149c0ea04fde01eb6b187bbb9"></a><!-- doxytag: member="ArSocket::myStringAutoEcho" ref="24447d6149c0ea04fde01eb6b187bbb9" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringAutoEcho</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3df5953b862720adca9014038c06d99b"></a><!-- doxytag: member="ArSocket::myStringBuf" ref="3df5953b862720adca9014038c06d99b" args="[5000]" -->
char&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringBuf</b> [5000]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ca7a3f72c7dd547de73028724999dbd"></a><!-- doxytag: member="ArSocket::myStringBufEmpty" ref="6ca7a3f72c7dd547de73028724999dbd" args="[1]" -->
char&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringBufEmpty</b> [1]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="48a08ea0b08853114147a40184d1913f"></a><!-- doxytag: member="ArSocket::myStringEcho" ref="48a08ea0b08853114147a40184d1913f" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringEcho</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c78b34332a16f9283d14eaf47fc3b838"></a><!-- doxytag: member="ArSocket::myStringGotComplete" ref="c78b34332a16f9283d14eaf47fc3b838" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringGotComplete</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14993c1a7f213fef06e805e33c110b8d"></a><!-- doxytag: member="ArSocket::myStringGotEscapeChars" ref="14993c1a7f213fef06e805e33c110b8d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringGotEscapeChars</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8ae61b1a07a8fa5968bc4803debc4f8"></a><!-- doxytag: member="ArSocket::myStringHaveEchoed" ref="e8ae61b1a07a8fa5968bc4803debc4f8" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringHaveEchoed</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1dfff4427e00f1cca50bca6a241d6780"></a><!-- doxytag: member="ArSocket::myStringIgnoreReturn" ref="1dfff4427e00f1cca50bca6a241d6780" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringIgnoreReturn</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ecec1138e16619492cd0aff0b6f1fb4"></a><!-- doxytag: member="ArSocket::myStringPos" ref="1ecec1138e16619492cd0aff0b6f1fb4" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringPos</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf92a212f2fcbf853860409deb9d0cb0"></a><!-- doxytag: member="ArSocket::myStringPosLast" ref="bf92a212f2fcbf853860409deb9d0cb0" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringPosLast</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b76f280862e5eef9f581df3cac3d42d"></a><!-- doxytag: member="ArSocket::myStringWrongEndChars" ref="8b76f280862e5eef9f581df3cac3d42d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStringWrongEndChars</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="929f2fe07643d38b3a7f53034629a862"></a><!-- doxytag: member="ArSocket::myType" ref="929f2fe07643d38b3a7f53034629a862" args="" -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><b>myType</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="08647d6a474acb14498901b062a806d3"></a><!-- doxytag: member="ArSocket::myWriteStringMutex" ref="08647d6a474acb14498901b062a806d3" args="" -->
<a class="el" href="classArMutex.html">ArMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myWriteStringMutex</b></td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="612acf14e9aca4e12e931784a5147513"></a><!-- doxytag: member="ArSocket::ArSocket" ref="612acf14e9aca4e12e931784a5147513" args="(const char *host, int port, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArSocket::ArSocket           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor which automatically connects to a server as a client. 
<p>
Constructs the socket and connects it to the given host. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>host</em>&nbsp;</td><td>hostname of the server to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>port number of the server to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>protocol type to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="133fce4174f7a64327353510804796e9"></a><!-- doxytag: member="ArSocket::ArSocket" ref="133fce4174f7a64327353510804796e9" args="(int port, bool doClose, Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArSocket::ArSocket           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doClose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor which outomatically opens a server port. 
<p>
Constructs the socket and opens it as a server port. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>port number to bind the socket to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doClose</em>&nbsp;</td><td>automaticaly close the port if the socket is destructed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>protocol type to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6647efb8d20f9523dad090a68b1e4e2c"></a><!-- doxytag: member="ArSocket::accept" ref="6647efb8d20f9523dad090a68b1e4e2c" args="(ArSocket *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArSocket.html">ArSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>sock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept a new connection. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there are no errors, false if there are errors... not that if you're in non-blocking mode and there is no socket to connect that is NOT an error, you'll want to check the getFD on the sock you pass in to see if it is actually a valid socket.<p>
false and set error code and description string on failure </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="socketServerExample_8cpp-example.html#a8">socketServerExample.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="666b81136fa241062dfdc4aff63913f3"></a><!-- doxytag: member="ArSocket::addrHost" ref="666b81136fa241062dfdc4aff63913f3" args="(struct in_addr &amp;addr, char *host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::addrHost           </td>
          <td>(</td>
          <td class="paramtype">struct in_addr &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>host</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert an address structure to a hostname string. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="89ab9a4e404526343ccf6ba3b6644c58"></a><!-- doxytag: member="ArSocket::close" ref="89ab9a4e404526343ccf6ba3b6644c58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::close           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the socket. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="socketClientExample_8cpp-example.html#a10">socketClientExample.cpp</a>, and <a class="el" href="socketServerExample_8cpp-example.html#a12">socketServerExample.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="e9d803dcf9ad0bb72b790d3098ca8dc5"></a><!-- doxytag: member="ArSocket::connect" ref="e9d803dcf9ad0bb72b790d3098ca8dc5" args="(const char *host, int port, Type type=TCP, const char *openOnIP=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::connect           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>TCP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>openOnIP</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect as a client to a server. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure<p>
false and set error code and description string on failure </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="socketClientExample_8cpp-example.html#a4">socketClientExample.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="53c91a81c037e89f8c451ed265664ae9"></a><!-- doxytag: member="ArSocket::connectTo" ref="53c91a81c037e89f8c451ed265664ae9" args="(struct sockaddr_in *sin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::connectTo           </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>sin</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect the socket to the given address. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="7264b5996106c967abad8260e416d4d1"></a><!-- doxytag: member="ArSocket::connectTo" ref="7264b5996106c967abad8260e416d4d1" args="(const char *host, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::connectTo           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect the socket to the given address. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="933a1ca8492112def78ce9129023fc33"></a><!-- doxytag: member="ArSocket::copy" ref="933a1ca8492112def78ce9129023fc33" args="(int fd, bool doclose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::copy           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doclose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy socket structures. 
<p>
Copy socket structures. Copy from one Socket to another will still have the first socket close the file descripter when it is destructed. <dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure.<p>
false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="65d4a673234731800cb0f0fd399f2e2a"></a><!-- doxytag: member="ArSocket::create" ref="65d4a673234731800cb0f0fd399f2e2a" args="(Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::create           </td>
          <td>(</td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simply create a port. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure<p>
false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="275484e4c9c98f05e61d7427ac3dcac6"></a><!-- doxytag: member="ArSocket::findValidPort" ref="275484e4c9c98f05e61d7427ac3dcac6" args="(int startPort, const char *openOnIP=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::findValidPort           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>openOnIP</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first valid unused port after <em>startPort</em>, and bind the socket to it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startPort</em>&nbsp;</td><td>first port to try </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>openOnIP</em>&nbsp;</td><td>If given, only check ports open on the interface accociated with this address (Linux only)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false on error<p>
false on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8bf1dbbb2aaecf96d23a13e68f68032"></a><!-- doxytag: member="ArSocket::getSockName" ref="e8bf1dbbb2aaecf96d23a13e68f68032" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::getSockName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get socket information (socket "name"). Aspects of this "name" are accessible with <a class="el" href="classArSocket.html#927ee1fa6eace33c6338f2644a614513" title="Accessor for the sockaddr.">sockAddrIn()</a>, <a class="el" href="classArSocket.html#8145c15c517a8be617630b22b854c4f4" title="Accessor for the in_addr part of sockaddr.">inAddr()</a>, <a class="el" href="classArSocket.html#34005874b46b174cfff549bcd8f50958" title="Accessor for the port of the sockaddr.">inPort()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="a11d9c51e510e4b7bfc35103bc3b4114"></a><!-- doxytag: member="ArSocket::hostAddr" ref="a11d9c51e510e4b7bfc35103bc3b4114" args="(const char *host, struct in_addr &amp;addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::hostAddr           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct in_addr &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a hostname string to an address structure. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="11b42725ca91a9d95cbe85f56feba58e"></a><!-- doxytag: member="ArSocket::init" ref="11b42725ca91a9d95cbe85f56feba58e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::init           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the OS sockets system, if neccesary. 
<p>
In Windows, the networking subsystem needs to be initialized and shutdown individyaly by each program. So when a program starts they will need to call the static function <a class="el" href="classArSocket.html#11b42725ca91a9d95cbe85f56feba58e" title="Initialize the OS sockets system, if neccesary.">ArSocket::init()</a> and call <a class="el" href="classArSocket.html#ec8534984137fb13a4f1e94c2b3839dc" title="Shutdown the OS sockets system, if neccesary.">ArSocket::shutdown()</a> when it exits. For programs that use <a class="el" href="classAria.html#d99c16b5d947229d9f8e1c5b2d4cdd73" title="Initialize Aria global data struture and perform OS-specific initialization, including...">Aria::init()</a> and <a class="el" href="classAria.html#5970d7ac6a16b99b0e08d4cbedd78724" title="Performs OS-specific deinitialization, used by shutdown() and exit().">Aria::uninit()</a> calling the <a class="el" href="classArSocket.html#11b42725ca91a9d95cbe85f56feba58e" title="Initialize the OS sockets system, if neccesary.">ArSocket::init()</a> and <a class="el" href="classArSocket.html#ec8534984137fb13a4f1e94c2b3839dc" title="Shutdown the OS sockets system, if neccesary.">ArSocket::shutdown()</a> is unnecessary. The <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> initialization functions take care of this. These functions do nothing in Linux.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a9bd59b92bd1018c8be0af39eac2dc8"></a><!-- doxytag: member="ArSocket::open" ref="7a9bd59b92bd1018c8be0af39eac2dc8" args="(int port, Type type, const char *openOnIP=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::open           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>openOnIP</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a server port<p>
Opens a server port, that is, a port that is bound to a local port (and optionally, address) and listens for new incoming connections. Use <a class="el" href="classArSocket.html#6647efb8d20f9523dad090a68b1e4e2c" title="Accept a new connection.">accept()</a> to wait for a new incoming connection from a client.<p>
In additon, internally this method calls setLinger(0), <a class="el" href="classArSocket.html#87e6aaf36163f42cac218333ecc078b7" title="Set the reuse address value.">setReuseAddress()</a>, and <a class="el" href="classArSocket.html#657700645f097c3b53c2f5bb8c97cb7e" title="Set socket to nonblocking. Most importantly, calls to read() will return immediately...">setNonBlock()</a> to turn on these options (having these on is particularly useful for servers).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>ArSocket::TCP or ArSocket::UDP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>openOnIP</em>&nbsp;</td><td>If given, only bind to the interface accociated with this address (Linux only) (by default, all interfaces are used)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure<p>
false and set error code and description string on failure </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="socketServerExample_8cpp-example.html#a2">socketServerExample.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="6cf324be0075d3469a70d01d4740e23c"></a><!-- doxytag: member="ArSocket::read" ref="6cf324be0075d3469a70d01d4740e23c" args="(void *buff, size_t len, unsigned int msWait=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArSocket::read           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>msWait</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data from the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>buffer to read into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>how many bytes to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msWait</em>&nbsp;</td><td>if 0, don't block, if &gt; 0 wait this long for data </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of bytes read </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="socketClientExample_8cpp-example.html#a7">socketClientExample.cpp</a>, and <a class="el" href="socketServerExample_8cpp-example.html#a11">socketServerExample.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="7a6449d5b385d44e26af4250eaf7658c"></a><!-- doxytag: member="ArSocket::readString" ref="7a6449d5b385d44e26af4250eaf7658c" args="(unsigned int msWait=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ArSocket::readString           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>msWait</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a string from the socket. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function can only read strings less than 512 characters long as it reads the characters into its own internal buffer (to compensate for some of the things the DOS telnet does).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msWait</em>&nbsp;</td><td>if 0, don't block, if &gt; 0 wait this long for data</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Data read, or an empty string (first character will be '\0') if no data was read. If there was an error reading from the socket, NULL is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5b1623bf035093715ab90af1677ce2f2"></a><!-- doxytag: member="ArSocket::recvFrom" ref="5b1623bf035093715ab90af1677ce2f2" args="(void *msg, int len, sockaddr_in *sin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArSocket::recvFrom           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>sin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a message (short string) from the socket. 
<p>
Normally, <a class="el" href="classArSocket.html#6cf324be0075d3469a70d01d4740e23c" title="Read data from the socket.">read()</a> should be used instead. This is a wrapper around the recvfrom() system call. 
</div>
</div><p>
<a class="anchor" name="7aa35f485bbdbacfe599617366d761ff"></a><!-- doxytag: member="ArSocket::sendTo" ref="7aa35f485bbdbacfe599617366d761ff" args="(const void *msg, int len, struct sockaddr_in *sin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArSocket::sendTo           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *&nbsp;</td>
          <td class="paramname"> <em>sin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message (short string) on the socket. 
<p>
Normally, <a class="el" href="classArSocket.html#f2cfbd564eec7020283f5a6fe41f558f" title="Write data to the socket.">write()</a> should be used instead. This is a wrapper around the sendto() system call. 
</div>
</div><p>
<a class="anchor" name="ad4e9284aa39028d770a6fef0ebb62a3"></a><!-- doxytag: member="ArSocket::sendTo" ref="ad4e9284aa39028d770a6fef0ebb62a3" args="(const void *msg, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArSocket::sendTo           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message (short string) on the socket. 
<p>
Normally, <a class="el" href="classArSocket.html#f2cfbd564eec7020283f5a6fe41f558f" title="Write data to the socket.">write()</a> should be used instead. This is a wrapper around the sendto() system call. 
</div>
</div><p>
<a class="anchor" name="946caf0804f5d91682d816d0995c84c2"></a><!-- doxytag: member="ArSocket::setBroadcast" ref="946caf0804f5d91682d816d0995c84c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::setBroadcast           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set broadcast value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure.<p>
false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee3f81f6d774f883b1ff46fe9d89d02f"></a><!-- doxytag: member="ArSocket::setLinger" ref="ee3f81f6d774f883b1ff46fe9d89d02f" args="(int time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::setLinger           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the linger value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure.<p>
false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c435287e6e2f778874dcc15c6aa4e27"></a><!-- doxytag: member="ArSocket::setNoDelay" ref="5c435287e6e2f778874dcc15c6aa4e27" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::setNoDelay           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets NODELAY option on TCP socket, which can reduce latency for small packet sizes. 
<p>
If this socket is a TCP socket, then set the TCP_NODELAY flag, to disable the use of the Nagle algorithm (which waits until enough data is ready to send to fill a TCP frame, rather then sending the packet immediately). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>true to turn on NoDelay, false to turn it off. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true of the flag was successfully set, false if there was an error or this socket is not a TCP socket.</dd></dl>
If this socket is a TCP socket, then set the TCP_NODELAY flag to 1, to disable the use of the Nagle algorithm (which waits until enough data is ready to send to fill a TCP frame, rather then sending the packet immediately). <dl class="return" compact><dt><b>Returns:</b></dt><dd>true of the flag was successfully set, false if there was an error or this socket is not a TCP socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="657700645f097c3b53c2f5bb8c97cb7e"></a><!-- doxytag: member="ArSocket::setNonBlock" ref="657700645f097c3b53c2f5bb8c97cb7e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::setNonBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set socket to nonblocking. Most importantly, calls to <a class="el" href="classArSocket.html#6cf324be0075d3469a70d01d4740e23c" title="Read data from the socket.">read()</a> will return immediately, even if no data is available. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure.<p>
false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="91f2b1736eefe5a0aa68664473a1bef5"></a><!-- doxytag: member="ArSocket::setRawIPString" ref="91f2b1736eefe5a0aa68664473a1bef5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSocket::setRawIPString           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the ip string internal function that sets the ip string from the inAddr 
</div>
</div><p>
<a class="anchor" name="87e6aaf36163f42cac218333ecc078b7"></a><!-- doxytag: member="ArSocket::setReuseAddress" ref="87e6aaf36163f42cac218333ecc078b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArSocket::setReuseAddress           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the reuse address value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false and set error code and description string on failure.<p>
false and set error code and description string on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec8534984137fb13a4f1e94c2b3839dc"></a><!-- doxytag: member="ArSocket::shutdown" ref="ec8534984137fb13a4f1e94c2b3839dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSocket::shutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shutdown the OS sockets system, if neccesary. 
<p>
In Windows, the networking subsystem needs to be initialized and shutdown individyaly by each program. So when a program starts they will need to call the static function <a class="el" href="classArSocket.html#11b42725ca91a9d95cbe85f56feba58e" title="Initialize the OS sockets system, if neccesary.">ArSocket::init()</a> and call <a class="el" href="classArSocket.html#ec8534984137fb13a4f1e94c2b3839dc" title="Shutdown the OS sockets system, if neccesary.">ArSocket::shutdown()</a> when it exits. For programs that use <a class="el" href="classAria.html#d99c16b5d947229d9f8e1c5b2d4cdd73" title="Initialize Aria global data struture and perform OS-specific initialization, including...">Aria::init()</a> and <a class="el" href="classAria.html#5970d7ac6a16b99b0e08d4cbedd78724" title="Performs OS-specific deinitialization, used by shutdown() and exit().">Aria::uninit()</a> calling the <a class="el" href="classArSocket.html#11b42725ca91a9d95cbe85f56feba58e" title="Initialize the OS sockets system, if neccesary.">ArSocket::init()</a> and <a class="el" href="classArSocket.html#ec8534984137fb13a4f1e94c2b3839dc" title="Shutdown the OS sockets system, if neccesary.">ArSocket::shutdown()</a> is unnecessary. The <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> initialization functions take care of this. These functions do nothing in Linux. 
</div>
</div><p>
<a class="anchor" name="a92f0db004d5642efb4298e4fcad2738"></a><!-- doxytag: member="ArSocket::transfer" ref="a92f0db004d5642efb4298e4fcad2738" args="(ArSocket *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSocket::transfer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArSocket.html">ArSocket</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfer ownership of a socket. 
<p>
<a class="el" href="classArSocket.html#a92f0db004d5642efb4298e4fcad2738" title="Transfer ownership of a socket.">transfer()</a> will transfer ownership to this socket. The input socket will no longer close the file descriptor when it is destructed. 
</div>
</div><p>
<a class="anchor" name="f2cfbd564eec7020283f5a6fe41f558f"></a><!-- doxytag: member="ArSocket::write" ref="f2cfbd564eec7020283f5a6fe41f558f" args="(const void *buff, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArSocket::write           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data to the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>buffer to write from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>how many bytes to write </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of bytes written </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="socketClientExample_8cpp-example.html#a9">socketClientExample.cpp</a>, and <a class="el" href="socketServerExample_8cpp-example.html#a10">socketServerExample.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="62c1a96eb8fa0dd1c384646228eac194"></a><!-- doxytag: member="ArSocket::writeString" ref="62c1a96eb8fa0dd1c384646228eac194" args="(const char *str,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArSocket::writeString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a string to the socket (adding end of line characters). 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArSocket.html#69ca55d1e3007e2743c53b038bbe62a7" title="Same as writeString(), but no varargs.">writeStringPlain()</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="netServerExample_8cpp-example.html#a1">netServerExample.cpp</a>.</dl>
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>ArSocket.h<li>ArSocket.cpp<li>ArSocket_LIN.cpp<li>ArSocket_WIN.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 1 12:22:52 2012 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
