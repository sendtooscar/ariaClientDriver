<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Aria: ArSignalHandler Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ArSignalHandler Class Reference</h1><!-- doxytag: class="ArSignalHandler" --><!-- doxytag: inherits="ArASyncTask" --><code>#include &lt;ArSignalHandler.h&gt;</code>
<p>
Inherits <a class="el" href="classArASyncTask.html">ArASyncTask</a>.
<p>

<p>
<a href="classArSignalHandler-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Signal handling class. 
<p>
This is a signal handling class. It has both a threaded and non-threaded mode of operation. The non-threaded mode will work in a threaded application but it is best to use the threaded mode. The benefit of the threaded mode is that if the signal incures some processing, but does not shutdown the program (ie. SIGUSR1 or SIGUSR2), the threaded mode will handle the signal in its own thread and hopefully that will not hurt the performance of the tight loop robot control. Exaclty how much performance you get out of this depends on your machines physical hardware and exactly what the processing the signal handler does. For instance, a multi-processor machine has a much greater chance of the signal handler not interfering with the robot control loop.<p>
See the <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> main class for how to initialize a default setup of the signal handling.<p>
There are functions to block, unblock, handle and unhandle signals. These functions all must be called before creating the signalhandler. In either single or multi-threaded mode. The functions to block and handle signals creates a set of blocking and handling which is then used by the create functions to tell the Linux kernel what to do.<p>
In the threaded mode, there is a signal handler thread that is created. That thread is created in a detached state, which means it can not be joined on. When the program exits, the signal handler thread will be ignored and that thread will never exit its run loop. This is perfectly fine behavior. There is no state that can be messed up in this fashion. It is just easier to exit the program than to try to wake up that thread and get it to exit itself.<p>
This class is for Linux only. Windows has virtualy no support for signals and the little support that it does have is not realy usefull. There is an empty implementation of this class for Windows so that code can compile in both Linux and Windows. Just do not expect the code that uses this signal handling to do anything in Windows. This should not be a problem since signals are not used in Windows. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Signal</b> { <br>
&nbsp;&nbsp;<b>SigHUP</b> = 1, 
<b>SigINT</b>, 
<b>SigQUIT</b>, 
<b>SigILL</b>, 
<br>
&nbsp;&nbsp;<b>SigTRAP</b>, 
<b>SigABRT</b>, 
<b>SigBUS</b>, 
<b>SigFPE</b>, 
<br>
&nbsp;&nbsp;<b>SigKILL</b>, 
<b>SigUSR1</b>, 
<b>SigSEGV</b>, 
<b>SigUSR2</b>, 
<br>
&nbsp;&nbsp;<b>SigPIPE</b>, 
<b>SigALRM</b>, 
<b>SigTERM</b>, 
<b>SigSTKFLT</b>, 
<br>
&nbsp;&nbsp;<b>SigCHLD</b>, 
<b>SigCONT</b>, 
<b>SigSTOP</b>, 
<b>SigTSTP</b>, 
<br>
&nbsp;&nbsp;<b>SigTTIN</b>, 
<b>SigTTOU</b>, 
<b>SigURG</b>, 
<b>SigXCPU</b>, 
<br>
&nbsp;&nbsp;<b>SigXFSZ</b>, 
<b>SigVTALRM</b>, 
<b>SigPROF</b>, 
<b>SigWINCH</b>, 
<br>
&nbsp;&nbsp;<b>SigIO</b>, 
<b>SigPWR</b>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="307e762ba1088d3a120d314b0156b15e"></a><!-- doxytag: member="ArSignalHandler::runThread" ref="307e762ba1088d3a120d314b0156b15e" args="(void *arg)" -->
virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>runThread</b> (void *arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="50c08e255b08ab66b81693e07876e38f"></a><!-- doxytag: member="ArSignalHandler::~ArSignalHandler" ref="50c08e255b08ab66b81693e07876e38f" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#50c08e255b08ab66b81693e07876e38f">~ArSignalHandler</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#48cf6dfa9c6f95864534b4d87849e033">addHandlerCB</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *func, <a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a handler callback.  <a href="#48cf6dfa9c6f95864534b4d87849e033"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#ce80ef77760a9c47639a82ba891d2c9b">block</a> (Signal sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the given signal.  <a href="#ce80ef77760a9c47639a82ba891d2c9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4df88f6d1c86dd2367be1a490cd59104"></a><!-- doxytag: member="ArSignalHandler::blockAllThisThread" ref="4df88f6d1c86dd2367be1a490cd59104" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#4df88f6d1c86dd2367be1a490cd59104">blockAllThisThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block all the signals for the calling thread only. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#c3905b131f4224e7cbaec67de0cd3d49">blockCommon</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block all the common signals the kill a program.  <a href="#c3905b131f4224e7cbaec67de0cd3d49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aacbb0de60881c236fbb01eafab26c0f">blockCommonThisThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block all the common signals for the calling thread only.  <a href="#aacbb0de60881c236fbb01eafab26c0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#3ec75831b5c143668b4aefba87fd5f6e">createHandlerNonThreaded</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the signal handling for a non-threaded program.  <a href="#3ec75831b5c143668b4aefba87fd5f6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#01509c79a6be50f527c0aa04efdfddf6">createHandlerThreaded</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the signal handling for a multi-threaded program.  <a href="#01509c79a6be50f527c0aa04efdfddf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#aefe2eba1ea2ea8d686813ad0edc86ac">delAllHandlerCBs</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the handlers.  <a href="#aefe2eba1ea2ea8d686813ad0edc86ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#56c5f923669397fad6eb6a513f978b6f">delHandlerCB</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a handler callback.  <a href="#56c5f923669397fad6eb6a513f978b6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classArSignalHandler.html">ArSignalHandler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a8a7697764708f84daa86c53f0fdc682">getHandler</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the single <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a> instance.  <a href="#a8a7697764708f84daa86c53f0fdc682"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#a2645175511274d6816b24c2b190f827">handle</a> (Signal sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle the given signal.  <a href="#a2645175511274d6816b24c2b190f827"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="39fa57bedbb7ccf657c8c5106903ee25"></a><!-- doxytag: member="ArSignalHandler::logThread" ref="39fa57bedbb7ccf657c8c5106903ee25" args="(void)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>logThread</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5be3b4e338a9a54df36a81f1619d02fa"></a><!-- doxytag: member="ArSignalHandler::nameSignal" ref="5be3b4e338a9a54df36a81f1619d02fa" args="(int sig)" -->
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#5be3b4e338a9a54df36a81f1619d02fa">nameSignal</a> (int sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the given signal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78ba0630454de3eb86707eb7b6c02cf8"></a><!-- doxytag: member="ArSignalHandler::signalCB" ref="78ba0630454de3eb86707eb7b6c02cf8" args="(int sig)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>signalCB</b> (int sig)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#edd9a39d9b5aabcc93544706253f8d1c">unblock</a> (Signal sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock the given signal.  <a href="#edd9a39d9b5aabcc93544706253f8d1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#0d8582a19d463dc7618188701061a14b">unblockAll</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock all the signals.  <a href="#0d8582a19d463dc7618188701061a14b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArSignalHandler.html#6ac04eee0943686bd97006a57f185192">unhandle</a> (Signal sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dont handle the given signal.  <a href="#6ac04eee0943686bd97006a57f185192"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0868e84f292fdaba87bc9abc599f6020"></a><!-- doxytag: member="ArSignalHandler::initSigMap" ref="0868e84f292fdaba87bc9abc599f6020" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>initSigMap</b> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7824916846be32ead951de403ac9d740"></a><!-- doxytag: member="ArSignalHandler::ourIgnoreQUIT" ref="7824916846be32ead951de403ac9d740" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourIgnoreQUIT</b></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc9c752f74b7273b24036042b6df0cc8"></a><!-- doxytag: member="ArSignalHandler::ourBlockSigSet" ref="fc9c752f74b7273b24036042b6df0cc8" args="" -->
static sigset_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourBlockSigSet</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8b9dcfe55daa25b289bec031def90fc"></a><!-- doxytag: member="ArSignalHandler::ourHandlerList" ref="b8b9dcfe55daa25b289bec031def90fc" args="" -->
static std::list&lt; <a class="el" href="classArFunctor1.html">ArFunctor1</a><br>
&lt; int &gt; * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourHandlerList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d63a9af96e5f26b0a92af8a724985e1"></a><!-- doxytag: member="ArSignalHandler::ourHandleSigSet" ref="3d63a9af96e5f26b0a92af8a724985e1" args="" -->
static sigset_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourHandleSigSet</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="80ce9dae77f52333e4bb579820b6e8bf"></a><!-- doxytag: member="ArSignalHandler::ourSigMap" ref="80ce9dae77f52333e4bb579820b6e8bf" args="" -->
static ArStrMap&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourSigMap</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6586d0779e91ed5915e3d3a16f065ab"></a><!-- doxytag: member="ArSignalHandler::ourSignalHandler" ref="b6586d0779e91ed5915e3d3a16f065ab" args="" -->
static <a class="el" href="classArSignalHandler.html">ArSignalHandler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourSignalHandler</b> = 0</td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="48cf6dfa9c6f95864534b4d87849e033"></a><!-- doxytag: member="ArSignalHandler::addHandlerCB" ref="48cf6dfa9c6f95864534b4d87849e033" args="(ArFunctor1&lt; int &gt; *func, ArListPos::Pos position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::addHandlerCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#db42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a handler callback. 
<p>
Add a handler callback to the list of callbacks. When there is a signal sent to the process, the list of callbacks are invoked and passed the signal number. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>functor created from ArFunctorC1&lt;int&gt; which refers to the function to call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>whether to place the functor first or last </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ce80ef77760a9c47639a82ba891d2c9b"></a><!-- doxytag: member="ArSignalHandler::block" ref="ce80ef77760a9c47639a82ba891d2c9b" args="(Signal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::block           </td>
          <td>(</td>
          <td class="paramtype">Signal&nbsp;</td>
          <td class="paramname"> <em>sig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block the given signal. 
<p>
Block the given signal. Call this before calling createHandlerNonThreaded or createHandlerThreaded. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td>the number of the signal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c3905b131f4224e7cbaec67de0cd3d49"></a><!-- doxytag: member="ArSignalHandler::blockCommon" ref="c3905b131f4224e7cbaec67de0cd3d49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::blockCommon           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block all the common signals the kill a program. 
<p>
Sets the signal handler to block all the common signals. The 'common' signals are SIGHUP, SIGINT, SIGQUIT, SIGTERM, SIGSEGV, and SIGPIPE. Call this before calling createHandlerNonThreaded or createHandlerThreaded. 
</div>
</div><p>
<a class="anchor" name="aacbb0de60881c236fbb01eafab26c0f"></a><!-- doxytag: member="ArSignalHandler::blockCommonThisThread" ref="aacbb0de60881c236fbb01eafab26c0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::blockCommonThisThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block all the common signals for the calling thread only. 
<p>
Block all the common signals for the calling thread. The calling thread will never receive the common signals which are SIGHUP, SIGINT, SIGQUIT, and SIGTERM. This function can be called at any time. 
</div>
</div><p>
<a class="anchor" name="3ec75831b5c143668b4aefba87fd5f6e"></a><!-- doxytag: member="ArSignalHandler::createHandlerNonThreaded" ref="3ec75831b5c143668b4aefba87fd5f6e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::createHandlerNonThreaded           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup the signal handling for a non-threaded program. 
<p>
Sets up the signal handling for a non-threaded program. When the program This uses the system call signal(2). This should not be used if you have a threaded program. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArSignalHandler.html#01509c79a6be50f527c0aa04efdfddf6" title="Setup the signal handling for a multi-threaded program.">createHandlerThreaded</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="01509c79a6be50f527c0aa04efdfddf6"></a><!-- doxytag: member="ArSignalHandler::createHandlerThreaded" ref="01509c79a6be50f527c0aa04efdfddf6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::createHandlerThreaded           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup the signal handling for a multi-threaded program. 
<p>
Sets up the signal handling for a threaded program. This call is only useful for Linux. This will create a dedicated thread in which to handle signals. The thread calls sigwait(3) and waits for a signal to be sent. By default all <a class="el" href="classArThread.html" title="POSIX/WIN32 thread wrapper class.">ArThread</a> instances block all signals. Thus the signal is sent to the signal handler thread. This will allow the other threads to continue uninterrupted and not skew their timing loops. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArSignalHandler.html#3ec75831b5c143668b4aefba87fd5f6e" title="Setup the signal handling for a non-threaded program.">createHandlerNonThreaded</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="aefe2eba1ea2ea8d686813ad0edc86ac"></a><!-- doxytag: member="ArSignalHandler::delAllHandlerCBs" ref="aefe2eba1ea2ea8d686813ad0edc86ac" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::delAllHandlerCBs           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the handlers. 
<p>
Removes all of the signal handler callback from the list of callbacks. 
</div>
</div><p>
<a class="anchor" name="56c5f923669397fad6eb6a513f978b6f"></a><!-- doxytag: member="ArSignalHandler::delHandlerCB" ref="56c5f923669397fad6eb6a513f978b6f" args="(ArFunctor1&lt; int &gt; *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::delHandlerCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; int &gt; *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a handler callback. 
<p>
Remove a handler callback from the list of callbacks. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>functor created from ArFunctorC1&lt;int&gt; which refers to the function to call. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a8a7697764708f84daa86c53f0fdc682"></a><!-- doxytag: member="ArSignalHandler::getHandler" ref="a8a7697764708f84daa86c53f0fdc682" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArSignalHandler.html">ArSignalHandler</a> * ArSignalHandler::getHandler           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the single <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a> instance. 
<p>
Get a pointer to the single instance of the <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a>. The signal handler uses the singleton model, which means there can only be one instance of <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a>. If the single instance of <a class="el" href="classArSignalHandler.html" title="Signal handling class.">ArSignalHandler</a> has not been created, getHandler will create it. This is how the handler should be created. <dl class="return" compact><dt><b>Returns:</b></dt><dd>returns a pointer to the instance of the signal handler </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2645175511274d6816b24c2b190f827"></a><!-- doxytag: member="ArSignalHandler::handle" ref="a2645175511274d6816b24c2b190f827" args="(Signal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::handle           </td>
          <td>(</td>
          <td class="paramtype">Signal&nbsp;</td>
          <td class="paramname"> <em>sig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handle the given signal. 
<p>
Handle the given signal. All the handler callbacks will be called with this signal when it is received. Call this before calling createHandlerNonThreaded or createHandlerThreaded. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td>the number of the signal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="edd9a39d9b5aabcc93544706253f8d1c"></a><!-- doxytag: member="ArSignalHandler::unblock" ref="edd9a39d9b5aabcc93544706253f8d1c" args="(Signal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::unblock           </td>
          <td>(</td>
          <td class="paramtype">Signal&nbsp;</td>
          <td class="paramname"> <em>sig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblock the given signal. 
<p>
Unblock the given signal. Call this before calling createHandlerNonThreaded or createHandlerThreaded. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td>the number of the signal </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d8582a19d463dc7618188701061a14b"></a><!-- doxytag: member="ArSignalHandler::unblockAll" ref="0d8582a19d463dc7618188701061a14b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::unblockAll           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblock all the signals. 
<p>
Unblock all the signals. Call this before calling createHandlerNonThreaded or createHandlerThreaded. 
</div>
</div><p>
<a class="anchor" name="6ac04eee0943686bd97006a57f185192"></a><!-- doxytag: member="ArSignalHandler::unhandle" ref="6ac04eee0943686bd97006a57f185192" args="(Signal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArSignalHandler::unhandle           </td>
          <td>(</td>
          <td class="paramtype">Signal&nbsp;</td>
          <td class="paramname"> <em>sig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dont handle the given signal. 
<p>
Do not handle the given signal. Call this before calling createHandlerNonThreaded or createHandlerThreaded. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td>the number of the signal </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>ArSignalHandler.h<li>ArSignalHandler_LIN.cpp<li>ArSignalHandler_WIN.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 1 12:22:52 2012 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
