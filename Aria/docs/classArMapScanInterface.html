<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Aria: ArMapScanInterface Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ArMapScanInterface Class Reference</h1><!-- doxytag: class="ArMapScanInterface" --><code>#include &lt;ArMapInterface.h&gt;</code>
<p>
Inherited by <a class="el" href="classArMapInterface.html">ArMapInterface</a>, and <a class="el" href="classArMapScan.html">ArMapScan</a>.
<p>

<p>
<a href="classArMapScanInterface-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Methods related to setting and retrieving the scan-related data in an <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map. 
<p>
<a class="el" href="classArMapScanInterface.html" title="Methods related to setting and retrieving the scan-related data in an Aria map.">ArMapScanInterface</a> is an abstract class that defines the methods used to manipulate obstacle data in an <a class="el" href="classAria.html" title="This class performs global initialization and deinitialization.">Aria</a> map. These generally include the points and lines detected by a particular sensor (a.k.a. scan type). <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#c2148e6b805f454df92629107524cc6b">addToFileParser</a> (<a class="el" href="classArFileParser.html">ArFileParser</a> *fileParser)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds handlers for this scan data's header information to the given file parser.  <a href="#c2148e6b805f454df92629107524cc6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97ab0fd481e4adbd043a6c565a577216"></a><!-- doxytag: member="ArMapScanInterface::ArMapScanInterface" ref="97ab0fd481e4adbd043a6c565a577216" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#97ab0fd481e4adbd043a6c565a577216">ArMapScanInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3e8606369e3f4676492c0c320370c9f"></a><!-- doxytag: member="ArMapScanInterface::getDisplayString" ref="a3e8606369e3f4676492c0c320370c9f" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDisplayString</b> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#fb1843e08cfcd465ed0e7b81bcb3a080">getLineMaxPose</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the upper right point (maximum x and y) of the scan's line segments.  <a href="#fb1843e08cfcd465ed0e7b81bcb3a080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#73ee1150e0bae55d06c90fe12a448226">getLineMinPose</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the lower left point (minimum x and y) of the scan's line segments.  <a href="#73ee1150e0bae55d06c90fe12a448226"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector<br>
&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#fb236644c2df2f7f1f65c94226a029da">getLines</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the line segments for the specified scan.  <a href="#fb236644c2df2f7f1f65c94226a029da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ab1cf68c7c01205c63fc7f64257d8e70">getMaxPose</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the upper right point (maximum x and y) of the scan's points.  <a href="#ab1cf68c7c01205c63fc7f64257d8e70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classArPose.html">ArPose</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#30c9b95c5162084dadb8602891254492">getMinPose</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the lower left point (minimum x and y) of the scan's points.  <a href="#30c9b95c5162084dadb8602891254492"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#89bc799ecce6710728ef14863fdc97b3">getNumLines</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of line segments in the specified scan.  <a href="#89bc799ecce6710728ef14863fdc97b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#891d5c22c516c783e947063298e34494">getNumPoints</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of points in the specified scan.  <a href="#891d5c22c516c783e947063298e34494"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#1dcd08b5cfc13ac5dc7d4b165d25bcaf">getPoints</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the map points for the specified scan.  <a href="#1dcd08b5cfc13ac5dc7d4b165d25bcaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#00e165a9f6d1accbf685fdf11bfe072e">getResolution</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the resolution (-1 if none specified).  <a href="#00e165a9f6d1accbf685fdf11bfe072e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#b832d545112db2fe6728a4c832e8dd1f">isSortedLines</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the line segment vector for the specified scan is sorted.  <a href="#b832d545112db2fe6728a4c832e8dd1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#96f6ecf236726619b8beca21d93b1d04">isSortedPoints</a> (const char *scanType=ARMAP_DEFAULT_SCAN_TYPE) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the point vector for the specified scan is sorted.  <a href="#96f6ecf236726619b8beca21d93b1d04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af3ec826e7b3180d0ea26071e735fba9"></a><!-- doxytag: member="ArMapScanInterface::loadDataPoint" ref="af3ec826e7b3180d0ea26071e735fba9" args="(double x, double y)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#af3ec826e7b3180d0ea26071e735fba9">loadDataPoint</a> (double x, double y)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the specified data point to the scan data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e19cc5a481b6c73369261a14d7c0c6e1"></a><!-- doxytag: member="ArMapScanInterface::loadLineSegment" ref="e19cc5a481b6c73369261a14d7c0c6e1" args="(double x1, double y1, double x2, double y2)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#e19cc5a481b6c73369261a14d7c0c6e1">loadLineSegment</a> (double x1, double y1, double x2, double y2)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the specified line segment to the scan data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#ec0a8ac2dfc18c01f1764e80a0e4588d">readDataPoint</a> (char *line)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a data point from the given line and adds it to this scan data.  <a href="#ec0a8ac2dfc18c01f1764e80a0e4588d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#a0ee33dcc7cafeb818b5fc3905be0dc1">readLineSegment</a> (char *line)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a line segment from the given line and adds it to this scan data.  <a href="#a0ee33dcc7cafeb818b5fc3905be0dc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#3a5ad36fe57fee02deacff8b7121a9c7">remFromFileParser</a> (<a class="el" href="classArFileParser.html">ArFileParser</a> *fileParser)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the handlers for this scan data's header information from the given file parser.  <a href="#3a5ad36fe57fee02deacff8b7121a9c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#89b013a50a0bebca595c3cc0d30dccd7">setLines</a> (const std::vector&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; *lines, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, bool isSortedLines=false, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the lines (copies those passed in).  <a href="#89b013a50a0bebca595c3cc0d30dccd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#b195302c09f759ed475f20ab9acc9ede">setPoints</a> (const std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; *points, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, bool isSortedPoints=false, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the points (copies those passed in).  <a href="#b195302c09f759ed475f20ab9acc9ede"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#dbff07c05db036ae2135a5686d23b13e">setResolution</a> (int resolution, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the resolution (-1 if none specified).  <a href="#dbff07c05db036ae2135a5686d23b13e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#56d0066fd304a1381a5b101317a437ab">writeLinesToFunctor</a> (<a class="el" href="classArFunctor2.html">ArFunctor2</a>&lt; int, std::vector&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; * &gt; *functor, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, <a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *keywordFunctor=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the map line segments to a functor.  <a href="#56d0066fd304a1381a5b101317a437ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#5c66d0c8ec8e74a1cae28fb5d26545d2">writePointsToFunctor</a> (<a class="el" href="classArFunctor2.html">ArFunctor2</a>&lt; int, std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; * &gt; *functor, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, <a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *keywordFunctor=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the scan data points to a functor.  <a href="#5c66d0c8ec8e74a1cae28fb5d26545d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#bb744ca0073a2624cf786710dd03de33">writeScanToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="31cb8d64d81abe99b086b104157b6cbc"></a><!-- doxytag: member="ArMapScanInterface::~ArMapScanInterface" ref="31cb8d64d81abe99b086b104157b6cbc" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#31cb8d64d81abe99b086b104157b6cbc">~ArMapScanInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d44443ed74d6fd42d7a63146b2c7c63"></a><!-- doxytag: member="ArMapScanInterface::isDefaultScanType" ref="3d44443ed74d6fd42d7a63146b2c7c63" args="(const char *scanType)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#3d44443ed74d6fd42d7a63146b2c7c63">isDefaultScanType</a> (const char *scanType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the given scan type is the default (i.e. no prefix on the map tags). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b1cf557a1fa8c18d71d5de70e8af549c"></a><!-- doxytag: member="ArMapScanInterface::isSummaryScanType" ref="b1cf557a1fa8c18d71d5de70e8af549c" args="(const char *scanType)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapScanInterface.html#b1cf557a1fa8c18d71d5de70e8af549c">isSummaryScanType</a> (const char *scanType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether the given scan type represents the summary of all other scan types. <br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c2148e6b805f454df92629107524cc6b"></a><!-- doxytag: member="ArMapScanInterface::addToFileParser" ref="c2148e6b805f454df92629107524cc6b" args="(ArFileParser *fileParser)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapScanInterface::addToFileParser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFileParser.html">ArFileParser</a> *&nbsp;</td>
          <td class="paramname"> <em>fileParser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds handlers for this scan data's header information to the given file parser. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileParser</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFileParser.html" title="Class for parsing files more easily.">ArFileParser</a> to which to add the handlers </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the handlers were successfully added; false if an error occurred </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb1843e08cfcd465ed0e7b81bcb3a080"></a><!-- doxytag: member="ArMapScanInterface::getLineMaxPose" ref="fb1843e08cfcd465ed0e7b81bcb3a080" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArPose.html">ArPose</a> ArMapScanInterface::getLineMaxPose           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the upper right point (maximum x and y) of the scan's line segments. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the maximum line segment pose; if ARMAP_SUMMARY_SCAN_TYPE, then the maximum line segment pose for all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="73ee1150e0bae55d06c90fe12a448226"></a><!-- doxytag: member="ArMapScanInterface::getLineMinPose" ref="73ee1150e0bae55d06c90fe12a448226" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArPose.html">ArPose</a> ArMapScanInterface::getLineMinPose           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the lower left point (minimum x and y) of the scan's line segments. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the minimum line segment pose; if ARMAP_SUMMARY_SCAN_TYPE, then the minimum line segment pose for all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fb236644c2df2f7f1f65c94226a029da"></a><!-- doxytag: member="ArMapScanInterface::getLines" ref="fb236644c2df2f7f1f65c94226a029da" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classArLineSegment.html">ArLineSegment</a>&gt;* ArMapScanInterface::getLines           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the line segments for the specified scan. 
<p>
Note that this returns a pointer to the object's internal vector. The map must be locked before this method is called, and must be unlocked after the caller has finished using the vector. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the line segments; must be non-NULL </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the std::vector&lt;ArPose&gt; that contains the specified scan's points; NULL if the scanType is undefined for the map </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab1cf68c7c01205c63fc7f64257d8e70"></a><!-- doxytag: member="ArMapScanInterface::getMaxPose" ref="ab1cf68c7c01205c63fc7f64257d8e70" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArPose.html">ArPose</a> ArMapScanInterface::getMaxPose           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the upper right point (maximum x and y) of the scan's points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the maximum pose; if ARMAP_SUMMARY_SCAN_TYPE, then the maximum pose for all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="30c9b95c5162084dadb8602891254492"></a><!-- doxytag: member="ArMapScanInterface::getMinPose" ref="30c9b95c5162084dadb8602891254492" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArPose.html">ArPose</a> ArMapScanInterface::getMinPose           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the lower left point (minimum x and y) of the scan's points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the minimum pose; if ARMAP_SUMMARY_SCAN_TYPE, then the minimum pose for all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="89bc799ecce6710728ef14863fdc97b3"></a><!-- doxytag: member="ArMapScanInterface::getNumLines" ref="89bc799ecce6710728ef14863fdc97b3" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ArMapScanInterface::getNumLines           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of line segments in the specified scan. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the line segment count; if ARMAP_SUMMARY_SCAN_TYPE, then the line segment count for all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="891d5c22c516c783e947063298e34494"></a><!-- doxytag: member="ArMapScanInterface::getNumPoints" ref="891d5c22c516c783e947063298e34494" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ArMapScanInterface::getNumPoints           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of points in the specified scan. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the point count; if ARMAP_SUMMARY_SCAN_TYPE, then the point count for all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1dcd08b5cfc13ac5dc7d4b165d25bcaf"></a><!-- doxytag: member="ArMapScanInterface::getPoints" ref="1dcd08b5cfc13ac5dc7d4b165d25bcaf" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classArPose.html">ArPose</a>&gt;* ArMapScanInterface::getPoints           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the map points for the specified scan. 
<p>
Note that this returns a pointer to the object's internal vector. The map must be locked before this method is called, and must be unlocked after the caller has finished using the vector. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the points; must be non-NULL </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the std::vector&lt;ArPose&gt; that contains the specified scan's points; NULL if the scanType is undefined for the map </dd></dl>

</div>
</div><p>
<a class="anchor" name="00e165a9f6d1accbf685fdf11bfe072e"></a><!-- doxytag: member="ArMapScanInterface::getResolution" ref="00e165a9f6d1accbf685fdf11bfe072e" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ArMapScanInterface::getResolution           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the resolution (-1 if none specified). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan for which to return the resolution; if ARMAP_SUMMARY_SCAN_TYPE then the lowest resolution (highest numerical value) of all scans is returned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b832d545112db2fe6728a4c832e8dd1f"></a><!-- doxytag: member="ArMapScanInterface::isSortedLines" ref="b832d545112db2fe6728a4c832e8dd1f" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapScanInterface::isSortedLines           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the line segment vector for the specified scan is sorted. 
<p>
Note that this method returns the state of the line segment vector when it was read from the file, or after setLines has been called. If the application calls getLines and directly manipulates the line segment vector's contents, then isSortedLines will not necessarily be correct.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the sorted state; if ARMAP_SUMMARY_SCAN_TYPE, then this method returns true if and only if all scans have sorted line segments </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="96f6ecf236726619b8beca21d93b1d04"></a><!-- doxytag: member="ArMapScanInterface::isSortedPoints" ref="96f6ecf236726619b8beca21d93b1d04" args="(const char *scanType=ARMAP_DEFAULT_SCAN_TYPE) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapScanInterface::isSortedPoints           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the point vector for the specified scan is sorted. 
<p>
Note that this method returns the state of the point vector when it was read from the file, or after setPoints has been called. If the application calls getPoints and directly manipulates the point vector's contents, then isSortedPoints will not necessarily be correct.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to return the sorted state; if ARMAP_SUMMARY_SCAN_TYPE, then this method returns true if and only if all scans have sorted points </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec0a8ac2dfc18c01f1764e80a0e4588d"></a><!-- doxytag: member="ArMapScanInterface::readDataPoint" ref="ec0a8ac2dfc18c01f1764e80a0e4588d" args="(char *line)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapScanInterface::readDataPoint           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a data point from the given line and adds it to this scan data. 
<p>
The data point is expected to be two integers (x y), separated by whitespace. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>the char * text line to be parsed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the point was successfully read and added to this scan data; false if an error occurred </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0ee33dcc7cafeb818b5fc3905be0dc1"></a><!-- doxytag: member="ArMapScanInterface::readLineSegment" ref="a0ee33dcc7cafeb818b5fc3905be0dc1" args="(char *line)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapScanInterface::readLineSegment           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a line segment from the given line and adds it to this scan data. 
<p>
The line segment is expected to be four integers (x1 y1 x2 y2), separated by whitespace <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>the char * text line to be parsed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the line segment was successfully read and added to this scan data; false if an error occurred </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a5ad36fe57fee02deacff8b7121a9c7"></a><!-- doxytag: member="ArMapScanInterface::remFromFileParser" ref="3a5ad36fe57fee02deacff8b7121a9c7" args="(ArFileParser *fileParser)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ArMapScanInterface::remFromFileParser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFileParser.html">ArFileParser</a> *&nbsp;</td>
          <td class="paramname"> <em>fileParser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the handlers for this scan data's header information from the given file parser. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileParser</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFileParser.html" title="Class for parsing files more easily.">ArFileParser</a> from which to remove the handlers </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bool true if the handlers were successfully removed; false if an error occurred </dd></dl>

</div>
</div><p>
<a class="anchor" name="89b013a50a0bebca595c3cc0d30dccd7"></a><!-- doxytag: member="ArMapScanInterface::setLines" ref="89b013a50a0bebca595c3cc0d30dccd7" args="(const std::vector&lt; ArLineSegment &gt; *lines, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, bool isSortedLines=false, ArMapChangeDetails *changeDetails=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapScanInterface::setLines           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isSortedLines</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *&nbsp;</td>
          <td class="paramname"> <em>changeDetails</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the lines (copies those passed in). 
<p>
This method will sort the given line segments in ascending order (according to the <a class="el" href="classArLineSegment.html" title="Represents a line segment in two-dimensional space.">ArLineSegment</a> less-than operator. If the vector is already sorted, then set the isSortedLiens parameter to true in order to improve performance. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lines</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArLineSegment.html" title="Represents a line segment in two-dimensional space.">ArLineSegment</a> vector to be copied to the scan data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to set the points; must not be ARMAP_SUMMARY_SCAN_TYPE or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isSortedLines</em>&nbsp;</td><td>a bool set to true if the line segment vector has already been sorted in ascending order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>changeDetails</em>&nbsp;</td><td>a pointer to the optional <a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> in which to store a description of the changes to the scan data; if NULL then the changes are not tracked. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b195302c09f759ed475f20ab9acc9ede"></a><!-- doxytag: member="ArMapScanInterface::setPoints" ref="b195302c09f759ed475f20ab9acc9ede" args="(const std::vector&lt; ArPose &gt; *points, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, bool isSortedPoints=false, ArMapChangeDetails *changeDetails=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapScanInterface::setPoints           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isSortedPoints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *&nbsp;</td>
          <td class="paramname"> <em>changeDetails</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the points (copies those passed in). 
<p>
This method will sort the given points in ascending order (according to the <a class="el" href="classArPose.html" title="The class which represents an x/y position along with a heading.">ArPose</a> less-than operator. If the points vector is already sorted, then set the isSortedPoints parameter to true in order to improve performance. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArPose.html" title="The class which represents an x/y position along with a heading.">ArPose</a> vector to be copied to the scan data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan type for which to set the points; must not be ARMAP_SUMMARY_SCAN_TYPE or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isSortedPoints</em>&nbsp;</td><td>a bool set to true if the points vector has already been sorted in ascending order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>changeDetails</em>&nbsp;</td><td>a pointer to the optional <a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> in which to store a description of the changes to the scan data; if NULL then the changes are not tracked. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbff07c05db036ae2135a5686d23b13e"></a><!-- doxytag: member="ArMapScanInterface::setResolution" ref="dbff07c05db036ae2135a5686d23b13e" args="(int resolution, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, ArMapChangeDetails *changeDetails=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapScanInterface::setResolution           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *&nbsp;</td>
          <td class="paramname"> <em>changeDetails</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the resolution (-1 if none specified). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resolution</em>&nbsp;</td><td>the int number of mm between the scan data point readings </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan for which to return the resolution; must not be ARMAP_SUMMARY_SCAN_TYPE or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>changeDetails</em>&nbsp;</td><td>a pointer to the optional <a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> in which to store a description of the changes to the scan data; if NULL then the changes are not tracked. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="56d0066fd304a1381a5b101317a437ab"></a><!-- doxytag: member="ArMapScanInterface::writeLinesToFunctor" ref="56d0066fd304a1381a5b101317a437ab" args="(ArFunctor2&lt; int, std::vector&lt; ArLineSegment &gt; * &gt; *functor, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, ArFunctor1&lt; const char * &gt; *keywordFunctor=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapScanInterface::writeLinesToFunctor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor2.html">ArFunctor2</a>&lt; int, std::vector&lt; <a class="el" href="classArLineSegment.html">ArLineSegment</a> &gt; * &gt; *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&nbsp;</td>
          <td class="paramname"> <em>keywordFunctor</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the map line segments to a functor. 
<p>
A pointer to the entire data line segment vector is passed directly to the functor in order to improve performance. The functor must not modify the vector's contents. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor2.html" title="Base class for functors with 2 parameters.">ArFunctor2</a> that takes the number of line segments and the vector of ArLineSegments, and writes the information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan points to be written; must not be ARMAP_SUMMARY_SCAN_TYPE or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keywordFunctor</em>&nbsp;</td><td>a pointer to an optional <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> that writes a text line to introduce the associated ArLineSegments; if NULL, then the header is not written </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c66d0c8ec8e74a1cae28fb5d26545d2"></a><!-- doxytag: member="ArMapScanInterface::writePointsToFunctor" ref="5c66d0c8ec8e74a1cae28fb5d26545d2" args="(ArFunctor2&lt; int, std::vector&lt; ArPose &gt; * &gt; *functor, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE, ArFunctor1&lt; const char * &gt; *keywordFunctor=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapScanInterface::writePointsToFunctor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor2.html">ArFunctor2</a>&lt; int, std::vector&lt; <a class="el" href="classArPose.html">ArPose</a> &gt; * &gt; *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&nbsp;</td>
          <td class="paramname"> <em>keywordFunctor</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the scan data points to a functor. 
<p>
A pointer to the entire data point vector is passed directly to the functor in order to improve performance. The functor must not modify the vector's contents. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>a pointer to the <a class="el" href="classArFunctor2.html" title="Base class for functors with 2 parameters.">ArFunctor2</a> that takes the number of points and the vector of ArPoses, and writes the information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan points to be written; must not be ARMAP_SUMMARY_SCAN_TYPE or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keywordFunctor</em>&nbsp;</td><td>a pointer to an optional <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> that writes a text line to introduce the associated ArPoses; if NULL, then the header is not written </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb744ca0073a2624cf786710dd03de33"></a><!-- doxytag: member="ArMapScanInterface::writeScanToFunctor" ref="bb744ca0073a2624cf786710dd03de33" args="(ArFunctor1&lt; const char * &gt; *functor, const char *endOfLineChars, const char *scanType=ARMAP_DEFAULT_SCAN_TYPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ArMapScanInterface::writeScanToFunctor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>endOfLineChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scanType</em> = <code>ARMAP_DEFAULT_SCAN_TYPE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method writes a text line for each of the scan header attributes (such as MinPose, MaxPose, NumPoints). Depending on the scan type, a prefix may be prepended to the keyword (e.g. HokuyuURGMinPose).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the scan header information (as text lines) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endOfLineChars</em>&nbsp;</td><td>the const char * string to be appended to the end of each text line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scanType</em>&nbsp;</td><td>the const char * identifier of the scan data to be written to the functor; must not be ARMAP_SUMMARY_SCAN_TYPE or NULL </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ArMapInterface_8h.html">ArMapInterface.h</a><li>ArMapInterface.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 1 12:22:51 2012 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
