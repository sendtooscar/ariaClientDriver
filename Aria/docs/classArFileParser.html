<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Aria: ArFileParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ArFileParser Class Reference</h1><!-- doxytag: class="ArFileParser" --><code>#include &lt;ArFileParser.h&gt;</code>
<p>

<p>
<a href="classArFileParser-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Class for parsing files more easily. 
<p>
This class helps parse text files based on keywords followed by various values. To use it, add functors of different types of arguments with <a class="el" href="classArFileParser.html#e9685e3b4f3ed5bbd0f7107ab9d81122" title="Adds a functor to handle a keyword that wants an easily parsable string.">addHandler()</a>, then call <a class="el" href="classArFileParser.html#54539be017dc61f50eac8ae5983ead91" title="The function to parse a file.">parseFile()</a> to parse the file and invoke the various functors as items are read from the file. <a class="el" href="classArFileParser.html#54539be017dc61f50eac8ae5983ead91" title="The function to parse a file.">parseFile()</a> returns true if there were no errors parsing and false if there were errors.<p>
One side feature is that you can have ONE handler for the keyword NULL, and if there is a line read that isn't entirely comments or whitespace that handler will be given the line. There isn't an explicit set for them since then there'd be another set of 5 adds.<p>
There should be some whitespace after keywords in the file, and any semicolon (;) or hash mark (#) will act as a comment with the rest of the line ignored. (Alternative comment delimeters may be set using setCommentDelimeters()). If no handler exists for the first word the line is passed to the handler above for NULL. You can't have any lines longer than 10000 characters or keywords longer than 512 characters (though I don't know why you'd have either). If you have more than 2048 words on a line you'll have problems as well.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classArFileParser.html" title="Class for parsing files more easily.">ArFileParser</a> does not escape any special characters when writing or loading to/from a file. Therefore in general keywords, values, and comments must not contain characters which have special meaning in a config file, such as '#', ';', tab or newline. </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9685e3b4f3ed5bbd0f7107ab9d81122"></a><!-- doxytag: member="ArFileParser::addHandler" ref="e9685e3b4f3ed5bbd0f7107ab9d81122" args="(const char *keyword, ArRetFunctor1&lt; bool, ArArgumentBuilder * &gt; *functor)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#e9685e3b4f3ed5bbd0f7107ab9d81122">addHandler</a> (const char *keyword, <a class="el" href="classArRetFunctor1.html">ArRetFunctor1</a>&lt; bool, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a functor to handle a keyword that wants an easily parsable string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#c9ea873d4673c1e2c00c42434ed2276b">addHandlerWithError</a> (const char *keyword, <a class="el" href="classArRetFunctor3.html">ArRetFunctor3</a>&lt; bool, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *, char *, size_t &gt; *functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a functor to handle a keyword that wants an easily parsable string and returns error messages.  <a href="#c9ea873d4673c1e2c00c42434ed2276b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6aa9f97d58336b81d4475008c03597db"></a><!-- doxytag: member="ArFileParser::ArFileParser" ref="6aa9f97d58336b81d4475008c03597db" args="(const char *baseDirectory=&quot;./&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#6aa9f97d58336b81d4475008c03597db">ArFileParser</a> (const char *baseDirectory=&quot;./&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#0a2af2524acb8e7e02c87dc2944e40c2">clearCommentDelimiters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the strings used to mark comments in the file to be parsed.  <a href="#0a2af2524acb8e7e02c87dc2944e40c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f208f62d4f033e5a303c2dc11680301"></a><!-- doxytag: member="ArFileParser::getBaseDirectory" ref="0f208f62d4f033e5a303c2dc11680301" args="(void) const " -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#0f208f62d4f033e5a303c2dc11680301">getBaseDirectory</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the base directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#01ea53048ed82fc16ada1c6107809794">parseFile</a> (FILE *file, char *buffer, int bufferLength, bool continueOnErrors=true, char *errorBuffer=NULL, size_t errorBufferLen=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses an open file; the file is not closed by this method.  <a href="#01ea53048ed82fc16ada1c6107809794"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#54539be017dc61f50eac8ae5983ead91">parseFile</a> (const char *fileName, bool continueOnErrors=true, bool noFileNotFoundMessage=false, char *errorBuffer=NULL, size_t errorBufferLen=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function to parse a file.  <a href="#54539be017dc61f50eac8ae5983ead91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a1e7db097550a8a935738cdb13f3dde"></a><!-- doxytag: member="ArFileParser::parseLine" ref="1a1e7db097550a8a935738cdb13f3dde" args="(char *line, char *errorBuffer=NULL, size_t errorBufferLen=0)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#1a1e7db097550a8a935738cdb13f3dde">parseLine</a> (char *line, char *errorBuffer=NULL, size_t errorBufferLen=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to parse a single line. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a013644f03dc6f5da8614df0bea055f1"></a><!-- doxytag: member="ArFileParser::remHandler" ref="a013644f03dc6f5da8614df0bea055f1" args="(ArRetFunctor3&lt; bool, ArArgumentBuilder *, char *, size_t &gt; *functor)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#a013644f03dc6f5da8614df0bea055f1">remHandler</a> (<a class="el" href="classArRetFunctor3.html">ArRetFunctor3</a>&lt; bool, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *, char *, size_t &gt; *functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any handlers with this functor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c70da823dbd5729ec67793a055b71a62"></a><!-- doxytag: member="ArFileParser::remHandler" ref="c70da823dbd5729ec67793a055b71a62" args="(ArRetFunctor1&lt; bool, ArArgumentBuilder * &gt; *functor)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#c70da823dbd5729ec67793a055b71a62">remHandler</a> (<a class="el" href="classArRetFunctor1.html">ArRetFunctor1</a>&lt; bool, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any handlers with this functor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="809de3588ef4abe66b31352d526824aa"></a><!-- doxytag: member="ArFileParser::remHandler" ref="809de3588ef4abe66b31352d526824aa" args="(const char *keyword, bool logIfCannotFind=true)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#809de3588ef4abe66b31352d526824aa">remHandler</a> (const char *keyword, bool logIfCannotFind=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a handler for a keyword. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59f7aab40d8d4ac41b07d44e07a4d689"></a><!-- doxytag: member="ArFileParser::resetCounters" ref="59f7aab40d8d4ac41b07d44e07a4d689" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#59f7aab40d8d4ac41b07d44e07a4d689">resetCounters</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to reset counters. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fd276fae4c5c56dda18a4c8446d4368"></a><!-- doxytag: member="ArFileParser::setBaseDirectory" ref="5fd276fae4c5c56dda18a4c8446d4368" args="(const char *baseDirectory)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#5fd276fae4c5c56dda18a4c8446d4368">setBaseDirectory</a> (const char *baseDirectory)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the base directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#17264d80465f66ef31d2f6e6ac1ce266">setCommentDelimiters</a> (const std::list&lt; std::string &gt; &amp;delimiters)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the strings used to mark comments in the file to be parsed.  <a href="#17264d80465f66ef31d2f6e6ac1ce266"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f71cfefc3cd26797888178a1938d9a93"></a><!-- doxytag: member="ArFileParser::setMaxNumArguments" ref="f71cfefc3cd26797888178a1938d9a93" args="(size_t maxNumArguments=512)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#f71cfefc3cd26797888178a1938d9a93">setMaxNumArguments</a> (size_t maxNumArguments=512)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of arguments in a line we can expect. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="804ca9f50a61d95feb59d3b9c5269c7f"></a><!-- doxytag: member="ArFileParser::setPreParseFunctor" ref="804ca9f50a61d95feb59d3b9c5269c7f" args="(ArFunctor1&lt; const char * &gt; *functor)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setPreParseFunctor</b> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6118e1eaafc1f933c5a7eab96326598f"></a><!-- doxytag: member="ArFileParser::setQuiet" ref="6118e1eaafc1f933c5a7eab96326598f" args="(bool isQuiet)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#6118e1eaafc1f933c5a7eab96326598f">setQuiet</a> (bool isQuiet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn on this flag to reduce the number of verbose log messages. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc562cffbc6f3a02e0c1f25fc454f9ba"></a><!-- doxytag: member="ArFileParser::~ArFileParser" ref="fc562cffbc6f3a02e0c1f25fc454f9ba" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFileParser.html#fc562cffbc6f3a02e0c1f25fc454f9ba">~ArFileParser</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b8d08bf2b95f0f9cc7b9b7c90e070a9"></a><!-- doxytag: member="ArFileParser::myBaseDir" ref="3b8d08bf2b95f0f9cc7b9b7c90e070a9" args="" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myBaseDir</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59f8a34a40ede94cc0e9884d9d99b90d"></a><!-- doxytag: member="ArFileParser::myCommentDelimiterList" ref="59f8a34a40ede94cc0e9884d9d99b90d" args="" -->
std::list&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCommentDelimiterList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8839e37fd4d99e71fc0faf65929717a8"></a><!-- doxytag: member="ArFileParser::myIsQuiet" ref="8839e37fd4d99e71fc0faf65929717a8" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myIsQuiet</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96d65a6d967325e60840e0d6d08c0c59"></a><!-- doxytag: member="ArFileParser::myLineNumber" ref="96d65a6d967325e60840e0d6d08c0c59" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myLineNumber</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7341309402a973a9e62fcc6bf949bce5"></a><!-- doxytag: member="ArFileParser::myMap" ref="7341309402a973a9e62fcc6bf949bce5" args="" -->
std::map&lt; std::string, <br>
HandlerCBType <br>
*, <a class="el" href="structArStrCaseCmpOp.html">ArStrCaseCmpOp</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMap</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf306e2907093c6d71f548547634bc21"></a><!-- doxytag: member="ArFileParser::myMaxNumArguments" ref="cf306e2907093c6d71f548547634bc21" args="" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxNumArguments</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a926e9753d840e0a6ec2315c7b372802"></a><!-- doxytag: member="ArFileParser::myPreParseFunctor" ref="a926e9753d840e0a6ec2315c7b372802" args="" -->
<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myPreParseFunctor</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a42eec2544de45dbadac0a6c45c835f"></a><!-- doxytag: member="ArFileParser::myRemainderHandler" ref="8a42eec2544de45dbadac0a6c45c835f" args="" -->
HandlerCBType *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRemainderHandler</b></td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c9ea873d4673c1e2c00c42434ed2276b"></a><!-- doxytag: member="ArFileParser::addHandlerWithError" ref="c9ea873d4673c1e2c00c42434ed2276b" args="(const char *keyword, ArRetFunctor3&lt; bool, ArArgumentBuilder *, char *, size_t &gt; *functor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArFileParser::addHandlerWithError           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArRetFunctor3.html">ArRetFunctor3</a>&lt; bool, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *, char *, size_t &gt; *&nbsp;</td>
          <td class="paramname"> <em>functor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a functor to handle a keyword that wants an easily parsable string and returns error messages. 
<p>
This function has a different name than addProcessFileCB just so that if you mean to get this function but have the wrong functor you'll get an error. The rem's are the same though since that shouldn't matter. 
</div>
</div><p>
<a class="anchor" name="0a2af2524acb8e7e02c87dc2944e40c2"></a><!-- doxytag: member="ArFileParser::clearCommentDelimiters" ref="0a2af2524acb8e7e02c87dc2944e40c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArFileParser::clearCommentDelimiters           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the strings used to mark comments in the file to be parsed. 
<p>
Call this method to indicate that the file type to be parsed does not contain comments. 
</div>
</div><p>
<a class="anchor" name="01ea53048ed82fc16ada1c6107809794"></a><!-- doxytag: member="ArFileParser::parseFile" ref="01ea53048ed82fc16ada1c6107809794" args="(FILE *file, char *buffer, int bufferLength, bool continueOnErrors=true, char *errorBuffer=NULL, size_t errorBufferLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArFileParser::parseFile           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>continueOnErrors</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errorBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>errorBufferLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses an open file; the file is not closed by this method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>the open FILE* to be parsed; must not be NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>a non-NULL char array in which to read the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>the number of chars in the buffer; must be greater than 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>continueOnErrors</em>&nbsp;</td><td>a bool set to true if parsing should continue even after an error is detected</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>File pointer for a file to be parsed. The file must be open for reading (e.g. with <a class="el" href="classArUtil.html#0c4d240777628983e66005d7f7a4939c" title="Opens a file, defaulting it so that the file will close on exec.">ArUtil::fopen()</a>) and this pointer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>a non-NULL char array in which to read the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferLength</em>&nbsp;</td><td>the number of chars in the buffer; must be greater than 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>continueOnErrors</em>&nbsp;</td><td>a bool set to true if parsing should continue even after an error is detected </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorBuffer</em>&nbsp;</td><td>buffer to put errors into if not NULL. Only the first error is saved, and as soon as this function is called it immediately empties the errorBuffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorBufferLen</em>&nbsp;</td><td>the length of <em>errorBuffer</em> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="54539be017dc61f50eac8ae5983ead91"></a><!-- doxytag: member="ArFileParser::parseFile" ref="54539be017dc61f50eac8ae5983ead91" args="(const char *fileName, bool continueOnErrors=true, bool noFileNotFoundMessage=false, char *errorBuffer=NULL, size_t errorBufferLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ArFileParser::parseFile           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>continueOnErrors</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noFileNotFoundMessage</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errorBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>errorBufferLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function to parse a file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>the file to open</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>continueOnErrors</em>&nbsp;</td><td>whether to continue or immediately bail upon an error</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>noFileNotFoundMessage</em>&nbsp;</td><td>whether or not to log if we find a file (we normally want to but for robot param files that'd be too annoying since we test for a lot of files)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorBuffer</em>&nbsp;</td><td>buffer to put errors into if not NULL. Only the first error is saved, and as soon as this function is called it immediately empties the errorBuffer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorBufferLen</em>&nbsp;</td><td>the length of <em>errorBuffer</em> </td></tr>
  </table>
</dl>

<p>
if( setvbuf( file, buf, _IOFBF, sizeof( buf ) ) != 0 ) printf( "Incorrect type or size of buffer for file\n" ); else printf( "'file' now has a buffer of 1024 bytes\n" ); 
</div>
</div><p>
<a class="anchor" name="17264d80465f66ef31d2f6e6ac1ce266"></a><!-- doxytag: member="ArFileParser::setCommentDelimiters" ref="17264d80465f66ef31d2f6e6ac1ce266" args="(const std::list&lt; std::string &gt; &amp;delimiters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArFileParser::setCommentDelimiters           </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>delimiters</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the strings used to mark comments in the file to be parsed. 
<p>
By default, the ";" and "#" strings are used to indicate comments. Call this method to override the defaults.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>delimiters</em>&nbsp;</td><td>each string represents a comment delimiter. The comment delimiter and any following characters in the current line will be stripped during parsing of the file </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>ArFileParser.h<li>ArFileParser.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Aug 1 12:22:51 2012 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
